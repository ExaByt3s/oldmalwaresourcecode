using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Text;

namespace Stub.WinAPI
{
    class CAPI
    {
        public string DLL;

        public string Name;

        public MethodInfo EntryPoint;

        public object Execute(object[] arr_objParameters)
        {
            return this.EntryPoint.Invoke(null, arr_objParameters);   
        }
    }

    /// <summary>
    /// Dynamic API Call Engine
    /// Used for calling WinAPI without LoadLibrary, GetModuleHandle, GetProcAddress.
    /// PInvoke code is generated at Runtime and executed
    /// </summary>
    class CDynamicAPI
    {
        /// <summary>
        /// Currently loaded WinAPI.
        /// </summary>
        List<CAPI> m_lstAPI = null;

        public CDynamicAPI()
        {
            m_lstAPI = new List<CAPI>();
        }

        CAPI CreateAPI(string dll, string name, object[] parameters, Type returnType)
        {
            try
            {
                List<Type> typeList = new List<Type>();

                for (int i = 0; i < parameters.Length; i++)
                {
                    typeList.Add(parameters[i].GetType());
                }

                AssemblyBuilder A = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName("DynamicInvokeDll"), AssemblyBuilderAccess.Run);
                ModuleBuilder M = A.DefineDynamicModule("MB");
                MethodBuilder MB = M.DefinePInvokeMethod(name,
                                                        dll,
                                                        MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.PinvokeImpl,
                                                        CallingConventions.Standard,
                                                        returnType,
                                                        typeList.ToArray(),
                                                        CallingConvention.Winapi, CharSet.Unicode);


                MB.SetImplementationFlags(MethodImplAttributes.PreserveSig);
                M.CreateGlobalFunctions();
                MethodInfo x = M.GetMethod(name);

                CAPI NewAPI = new CAPI();
                NewAPI.Name = name;
                NewAPI.DLL = dll;
                NewAPI.EntryPoint = x;

                m_lstAPI.Add(NewAPI);

                return NewAPI;
            }
            catch { }
            return null;
        }

        public object CallAPI(string strDLL, string strName, object[] arr_objParameters, Type tReturnType)
        {
            CAPI API = this.FindAPI(strDLL, strName);

            if (API == null) API = this.CreateAPI(strDLL, strName, arr_objParameters, tReturnType);

            if (API == null) return null;

            return API.Execute(arr_objParameters);
        }

        private CAPI FindAPI(string strDLL, string strName)
        {
            foreach(CAPI API in m_lstAPI.ToArray())
            {
                if (API.DLL != strDLL) continue;

                if (API.Name == strName)
                    return API;
            }
            return null;
        }
    }
}
