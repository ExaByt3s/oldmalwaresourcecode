using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using Server.Security;
using Server.Core.Config;
using Server.Utilities;
using System.Diagnostics;
using Server.Core.Handlers;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.Net.Security;
using System.Security.Authentication;

namespace Server.Core.Network
{
    #region SERVER_SOCKET_CLASS
    class CServerSocket
    {
        #region SERVER_SOCKET_EVENTS
        public delegate void delOnNewClient(CClient Client);
        public event delOnNewClient OnNewClient;
        public delegate void delOnNewData(CClient Client, Byte bPacket, Byte[] arr_bArguments);
        public event delOnNewData OnNewData;
        public delegate void delOnLostClient(CClient Client);
        public event delOnLostClient OnLostClient;
        #endregion

        #region PRIVATE_VARIABLES
        private Boolean AcceptConnections = false;
        private ManualResetEvent ConnectionAccepted = null;
        private Int32 ServerPort = -1;
        private X509Certificate2 m_SSLCertificate = null;
        #endregion

        #region SERVER_SOCKET_CONSTRUCTOR
        public CServerSocket(Int32 iPort)
        {
            if(iPort < 0 || iPort > 65535)
            {
                throw new ArgumentOutOfRangeException("iPort", "Port is out of range.");
            }

            if (!Directory.Exists("SSL"))
            {
                Directory.CreateDirectory("SSL");
                Console.WriteLine(CConstants.SSLDirectoryCreated);
                return;
            }

            try
            {
                m_SSLCertificate = new X509Certificate2(String.Format(@"SSL/{0}", CConfig.SSLCertificateFilename), CConfig.SSLPassword);
            }
            catch 
            {
                Console.WriteLine("SSL Certificate is missing.");
                Console.ReadKey();
                Environment.Exit(0);
            }

            this.ServerPort = iPort;
            this.ConnectionAccepted = new ManualResetEvent(false);
        }
        #endregion

        #region START_SERVER
        public Boolean StartServer()
        {
            if(this.AcceptConnections)
            {
                throw new Exception("Server is already running.");
            }

            if(this.ServerPort == -1)
            {
                throw new Exception("ServerPort is invalid.");
            }

            try
            {
                this.AcceptConnections = true;
                Thread tAcceptConnections = new Thread(new ThreadStart(this.Thread_AcceptConnections));
                tAcceptConnections.Start();
            }
            catch
            {
                this.AcceptConnections = false;
            }

            return this.AcceptConnections;
        }

        #endregion

        #region ACCPET_CONNECTIONS_THREAD
        void Thread_AcceptConnections()
        {
            while(this.AcceptConnections)
            {
                try
                {
                    Socket sockServer = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                    sockServer.ReceiveBufferSize = 8192;
                    sockServer.Bind((EndPoint)new IPEndPoint(IPAddress.Any, this.ServerPort));
                    sockServer.Listen(100);

                    while(true)
                    {
                        try
                        {
                            ConnectionAccepted.Reset();
                            sockServer.BeginAccept(new AsyncCallback(this.BeginAccept_Callback), sockServer);
                            ConnectionAccepted.WaitOne();
                        }
                        catch
                        {
                            break;
                        }
                    }
                }
                catch
                {
                	
                }
            }
        }
        #endregion

        #region CONNECTION_STRUCT
        struct SConnection
        {
        	public Socket ClientSocket;
        	public SslStream ClientStream;
        }
        #endregion

        #region BEGIN_ACCEPT_CALLBACK
        void BeginAccept_Callback(IAsyncResult iar)
        {
            Socket sockServer = null;

            try
            {
                sockServer = (Socket)iar.AsyncState;

                SConnection Connection = new SConnection();
                Connection.ClientSocket = sockServer.EndAccept(iar);
                Connection.ClientStream = new SslStream(new NetworkStream(Connection.ClientSocket), false);

                Connection.ClientStream.BeginAuthenticateAsServer(m_SSLCertificate, false, SslProtocols.Tls, true, new AsyncCallback(SSL_BeginAuthenticateAsServer_Callback), Connection);                
            }
            catch
            {
            	
            }

            this.ConnectionAccepted.Set();
        }
        #endregion

        #region SSL_AuthenticateAsServer_Callback
        void SSL_BeginAuthenticateAsServer_Callback(IAsyncResult iar)
        {
            try
            {
            	var Connection = (SConnection)iar.AsyncState;
            	
                Connection.ClientStream.EndAuthenticateAsServer(iar);

                CClient Client = new CClient(Connection.ClientStream, Connection.ClientSocket);
                Client.OnLostClient += Client_OnLostClient;
                Client.OnNewData += Client_OnNewData;
                if (Client.Start())
                {
                    if (this.OnNewClient != null)
                        this.OnNewClient.Invoke(Client);
                }
            }
            catch
            {
           	
            }
        }
        #endregion

        #region CLIENT_EVENTS
        void Client_OnNewData(CClient Client, Byte bPacket, Byte[] arr_bArguments)
        {
            if (this.OnNewData != null) 
            	this.OnNewData.Invoke(Client, bPacket, arr_bArguments);
        }

        void Client_OnLostClient(CClient Client)
        {
            if (this.OnLostClient != null)
                this.OnLostClient.Invoke(Client);
        }
        #endregion
    }
#endregion

	#region CLIENT_CLASS
    public class CClient
    {
        #region CLIENT_SOCKET_EVENTS
        public delegate void delOnNewData(CClient Client, Byte bPacket, Byte[] arr_bArguments);
        public event delOnNewData OnNewData;
        public delegate void delOnLostClient(CClient Client);
        public event delOnLostClient OnLostClient;
        #endregion

        #region PRIVATE_VARIABLES
        private SslStream m_ClientStream = null;
        private Socket m_ClientSocket = null;
        private CProtocol m_Protocol = null;
        #endregion

        #region CLIENT_CLASS_CONSTRUCTOR
        public CClient(SslStream ClientStream, Socket ClientSocket)
        {
            if (ClientStream == null)
                throw new ArgumentNullException("ClientStream");

            this.m_ClientStream = ClientStream;
            this.m_ClientSocket = ClientSocket;
            
            m_Protocol = new CProtocol();
            m_Protocol.OnPacketReceived += m_Protocol_OnPacketReceived;
        }

        #endregion

        #region ON_PACKET_RECEIVED
        void m_Protocol_OnPacketReceived(byte Packet, byte[] arr_bArguments)
        {
            if (OnNewData != null)
                OnNewData.Invoke(this, Packet, arr_bArguments);
        }
        #endregion

        #region START_CLIENT
        public Boolean Start()
        {
            if (m_ClientStream == null)
            {
                return false;
            }

            try
            {
                Byte[] arr_bBuffer = new Byte[8192];
                m_ClientStream.BeginRead(arr_bBuffer, 0, arr_bBuffer.Length, new AsyncCallback(SSL_BeginRead_Callback), arr_bBuffer);
                return true;
            }
            catch { }

            return false;
        }
        #endregion

        #region STOP_CLIENT
        public void Stop()
        {
            this.m_ClientStream.Close();
            this.m_ClientSocket.Close();
        }
        #endregion

        #region SSL_BeginRead_Callback
        void SSL_BeginRead_Callback(IAsyncResult iar)
        {
            try
            {
                int iDataRead = m_ClientStream.EndRead(iar);

                if (iDataRead == 0)
                {
                    if (this.OnLostClient != null)
                        this.OnLostClient.Invoke(this);
                }
                else if (iDataRead > 0)
                {
                    Byte[] arr_bRecvBuffer = (Byte[])iar.AsyncState;

                    Byte[] arr_bBuffer = new Byte[iDataRead];
                    Buffer.BlockCopy(arr_bRecvBuffer, 0, arr_bBuffer, 0, arr_bBuffer.Length);

                    m_Protocol.ProcessBuffer(arr_bBuffer);

                    arr_bRecvBuffer = new Byte[8192];
                    m_ClientStream.BeginRead(arr_bRecvBuffer, 0, arr_bRecvBuffer.Length, new AsyncCallback(SSL_BeginRead_Callback), arr_bRecvBuffer);
                }
            }
            catch
            {
            	if (this.OnLostClient != null) this.OnLostClient.Invoke(this);
            }
        }

        #endregion

        #region SEND_PACKET
        public bool SendPacket(CPacket Packet)
        {
            try
            {
                //Get Header
                Byte[] arr_bHeader = Packet.PacketHeader.ToByteArray();

                //Build Buffer
                Byte[] arr_bBuffer = new Byte[1 + arr_bHeader.Length];
                arr_bBuffer[0] = (Byte)PROTOCOL_PACKET.HEADER;
                Buffer.BlockCopy(arr_bHeader, 0, arr_bBuffer, 1, arr_bHeader.Length);

                //Send Header First
                if (this.SendData(arr_bBuffer))
                {
                    foreach (CPacketBlock Block in Packet.Data_Blocks)
                    {
                        String strBlock = Packet.PacketHeader.Packet_Ident + "|" + Block.ToString();

                        Byte[] arr_bBlock = UnicodeEncoding.Unicode.GetBytes(strBlock);

                        arr_bBuffer = new Byte[1 + arr_bBlock.Length];
                        arr_bBuffer[0] = (Byte)PROTOCOL_PACKET.BLOCK;
                        Buffer.BlockCopy(arr_bBlock, 0, arr_bBuffer, 1, arr_bBlock.Length);

                        if (!this.SendData(arr_bBuffer)) return false;
                    }
                }
                return true;
            }
            catch { }
            return false;
        }
        #endregion

        #region SEND_DATA
        bool SendData(Byte[] arr_bBuffer)
        {
            try
            {
                m_ClientStream.Write(arr_bBuffer);
                return true;
            }
            catch { }

            return false;
        }
        #endregion

        #region CREATE_PACKET
        public CPacket CreatePacket(Byte bPacket, Byte[] arr_bArguments)
        {
            return this.m_Protocol.CreatePacket(bPacket, arr_bArguments);
        }

        public CPacket CreatePacket(Byte bPacket, String strArguments)
        {
            return this.m_Protocol.CreatePacket(bPacket, strArguments);
        }
        #endregion

    }
#endregion
}
