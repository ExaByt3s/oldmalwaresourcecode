using System;
using System.Collections.Generic;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Threading;
using System.Diagnostics;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;

using Controller.Security;
using Controller.Core.Config;
using Controller.Utilities;
using Controller.Network.Gopnik;

namespace Controller.Network.Protocol
{
    class CClientSocket
    {
        public delegate void delOnClientConnected();
        public event delOnClientConnected OnClientConnected;
        public delegate void delOnClientReceiveData(CPacket Packet);
        public event delOnClientReceiveData OnClientReceiveData;
        public delegate void delOnClientDisconnect();
        public event delOnClientDisconnect OnClientDisconnect;
        public delegate void delOnLog(String strData);
        public event delOnLog OnLog;
        public delegate void delOnHeaderReceived(CPacketHeader Header);
        public event delOnHeaderReceived OnHeaderReceived;
        public delegate void delOnPacketReceived(string strPacketID);
        public event delOnPacketReceived OnPacketReceived;
        public delegate void delOnBlockReceived(string strPacketID);
        public event delOnBlockReceived OnBlockReceived;

        private String m_strOnionHost, m_strTorHost;
        private Int32 m_iOnionPort, m_iTorPort;

        private Boolean m_bIsRunning = false;
        private Boolean m_bIsConnected = false;

        private Socket MasterClient = null;
        private SslStream MasterStream = null;

        //Protocol
        private CProtocol m_Protocol = null;

        void LogData(String strData)
        {
            if (this.OnLog != null) this.OnLog.Invoke(strData);
        }

        public CClientSocket(String OnionHost, Int32 OnionPort, String TorHost, Int32 TorPort)
        {
            if(String.IsNullOrEmpty(OnionHost) == true)
            {
                throw new ArgumentNullException("OnionHost");
            }

            if(String.IsNullOrEmpty(TorHost) == true)
            {
                throw new ArgumentNullException("TorHost");
            }

            if(OnionPort < 0 || OnionPort > 65535)
            {
                throw new ArgumentOutOfRangeException("OnionPort");
            }

            if(TorPort < 0 || TorPort > 65535)
            {
                throw new ArgumentOutOfRangeException("TorPort");
            }

            this.m_strOnionHost = OnionHost;
            this.m_iOnionPort = OnionPort;
            this.m_strTorHost = TorHost;
            this.m_iTorPort = TorPort;

            m_Protocol = new CProtocol();
            m_Protocol.OnPacketReceived += m_Protocol_OnPacketReceived;
            m_Protocol.OnHeaderReceived += m_Protocol_OnHeaderReceived;
            m_Protocol.OnBlockReceived += delegate(string strPacketID)
            {
                if (this.OnBlockReceived != null) this.OnBlockReceived.Invoke(strPacketID);
            };
        }

        void m_Protocol_OnHeaderReceived(CPacketHeader Header)
        {
            if (this.OnHeaderReceived != null)
                this.OnHeaderReceived.Invoke(Header);
        }

        void m_Protocol_OnPacketReceived(CPacket Packet)
        {
            if (this.OnClientReceiveData != null)
                this.OnClientReceiveData.Invoke(Packet);
        }

        public CPacket CreatePacket(Byte Packet, Byte[] arr_bArguments)
        {
            return m_Protocol.CreatePacket(Packet, arr_bArguments);
        }

        public CPacket CreatePacket(Byte Packet, String strArguments)
        {
            return m_Protocol.CreatePacket(Packet, strArguments);
        }

        public Boolean IsRunning()
        {
            return this.m_bIsRunning;
        }

        public Boolean IsConnected()
        {
            return this.m_bIsConnected;
        }

        public void Disconnect()
        {
            try
            {
                if (MasterClient != null) MasterClient.Close();
            }
            catch
            {
            	
            }
        }
        public void Start()
        {
            if (m_bIsRunning == true) return;

            m_bIsRunning = true;

            try
            {
                this.LogData("Starting connection thread...");
                Thread tConnectionThread = new Thread(new ThreadStart(this.Connection_Thread));
                tConnectionThread.Start();
                this.LogData("Connection thread started.");
            }
            catch { }
        }

        static bool ValidateServerCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors Errors)
        {
            return true;
        }

        void Connection_Thread()
        {
            while(m_bIsRunning)
            {
                this.LogData("Connecting to Server...");
                try
                {
                	#if DEBUG
                	if(m_strOnionHost == "127.0.0.1")
                	{
                		MasterClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                		MasterClient.Connect((EndPoint)new IPEndPoint(IPAddress.Parse(m_strOnionHost), m_iOnionPort));
                	}
                	else
                	#endif
                    MasterClient = this.ConnectSocksProxy(this.m_strTorHost, (short)this.m_iTorPort, this.m_strOnionHost, (short)this.m_iOnionPort, MasterClient);
                    if (MasterClient == null)
                    {
                        /*
                         * ToDo:
                         * - Write to log (Failed to connect)
                         */

                        this.LogData("Failed to connect to Server");

                        Thread.Sleep(10 * 1000);
                        continue;
                    }
                    this.LogData("Connected to Server successfully.");
                    this.m_bIsConnected = true;

                    MasterStream = new SslStream(new NetworkStream(MasterClient), false, new RemoteCertificateValidationCallback(ValidateServerCertificate), null);
                    this.LogData("SSL Handshake started.");
                    MasterStream.AuthenticateAsClient("Client");
                    this.LogData("SSL Handshake finished.");

                    Byte[] arr_bBuffer = new Byte[MasterClient.ReceiveBufferSize];
                    MasterStream.BeginRead(arr_bBuffer, 0, arr_bBuffer.Length, new AsyncCallback(SSL_BeginRead_Callback), arr_bBuffer);

                    if(OnClientConnected != null) OnClientConnected.Invoke();
                    
                    while (this.m_bIsConnected) Thread.Sleep(10 * 1000);
                }
                catch
                {
                	
                }
                Thread.Sleep(10 * 1000);
            }
        }

        void SSL_BeginRead_Callback(IAsyncResult iar)
        {
            if (this.MasterClient == null || this.MasterStream == null)
            {
                this.m_bIsConnected = false;
                return;
            }

            try
            {
                Int32 iRead = MasterStream.EndRead(iar);
#if DEBUG
                LogData(string.Format("Received Data Size: [{0}]", iRead));
#endif
                if (iRead > 0)
                {
                    Byte[] arr_bBuffer = (Byte[])iar.AsyncState;

                    //Read Data into Buffer.
                    Byte[] arr_bRecvBuffer = new Byte[iRead];
                    Buffer.BlockCopy(arr_bBuffer, 0, arr_bRecvBuffer, 0, arr_bRecvBuffer.Length);

                   // new Thread(delegate()
                    //    {
                            if (!m_Protocol.ProcessBuffer(arr_bRecvBuffer))
                            {
                                if (OnLog != null) OnLog("ProcessBuffer failed. Contact Support.");
                            }
                        //}).Start();

                    //Receive next buffer
                    if (this.m_bIsRunning)
                    {
                        arr_bBuffer = new Byte[MasterClient.ReceiveBufferSize];
                        MasterStream.BeginRead(arr_bBuffer, 0, arr_bBuffer.Length, new AsyncCallback(SSL_BeginRead_Callback), arr_bBuffer);
                    }
                }
                else throw new Exception();
            }
            catch
            {
            	if(this.OnClientDisconnect != null) this.OnClientDisconnect.Invoke();
            	
                this.m_bIsConnected = false;
            }
        }

        public bool SendPacket(CPacket Packet)
        {
            try
            {
                //Get Header
                Byte[] arr_bHeader = Packet.PacketHeader.ToByteArray();

                //Build Buffer
                Byte[] arr_bBuffer = new Byte[1 + arr_bHeader.Length];
                arr_bBuffer[0] = (Byte)PROTOCOL_PACKET.HEADER;
                Buffer.BlockCopy(arr_bHeader, 0, arr_bBuffer, 1, arr_bHeader.Length);

                //Send Header First
                if(this.SendData(arr_bBuffer))
                {
                    foreach(CPacketBlock Block in Packet.Data_Blocks)
                    {
                        String strBlock = Packet.PacketHeader.Packet_Ident + "|" + Block.ToString();

                        Byte[] arr_bBlock = UnicodeEncoding.Unicode.GetBytes(strBlock);

                        arr_bBuffer = new Byte[1 + arr_bBlock.Length];
                        arr_bBuffer[0] = (Byte)PROTOCOL_PACKET.BLOCK;
                        Buffer.BlockCopy(arr_bBlock, 0, arr_bBuffer, 1, arr_bBlock.Length);

                        if (!this.SendData(arr_bBuffer)) return false;
                    }
                }
                return true;
            }
            catch { }
            return false;
        }

        public bool SendData(Byte[] arr_bBuffer)
        {
            if (!this.m_bIsConnected) return false;

            try
            {
                MasterStream.Write(arr_bBuffer);
                return true;
            }
            catch { }
            return false;
        }

        public void Stop()
        {
            m_bIsRunning = false;
            this.Disconnect();
        }


        Socket ConnectSocksProxy(string proxyDomain, short proxyPort, string host, short hostPort, Socket tc)
        {
            tc = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            tc.ReceiveBufferSize = 8192;
            tc.Connect(proxyDomain, proxyPort);

            byte[] HostNameBuf = new ASCIIEncoding().GetBytes(host);
            byte[] HostPortBuf = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(hostPort));

            byte[] bufout = new byte[128];
            int buflen = 0;
            tc.Send(new byte[] { 5, 1, 0 }, 0, 3, SocketFlags.None);
            buflen = tc.Receive(bufout, 0, bufout.Length, SocketFlags.None);
            if (buflen != 2 || bufout[0] != 5 || bufout[1] != 0)
                throw new Exception();

            byte[] buf = new byte[] { 5, 1, 0, 3, (byte)HostNameBuf.Length };
            MemoryStream mem = new MemoryStream();
            mem.Write(buf, 0, buf.Length);
            mem.Write(HostNameBuf, 0, HostNameBuf.Length);
            mem.Write(new byte[] { HostPortBuf[0], HostPortBuf[1] }, 0, 2);
            byte[] memarr = mem.ToArray();
            tc.Send(memarr, 0, memarr.Length, SocketFlags.None);
            buflen = tc.Receive(bufout, 0, bufout.Length, SocketFlags.None);
            if (bufout[0] != 5 || bufout[1] != 0)
                throw new Exception();

            return tc;
        }

        //Socket ConnectSocksProxy(String strTorHost, Int32 iTorPort, String strDestHost, Int32 iDestPort, Socket MasterClient)
        //{
        //    try
        //    {
        //        if (!strDestHost.EndsWith(".onion")) return null;

        //        Debug.WriteLine("Connecting to Tor..");
        //        MasterClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        //        MasterClient.Connect(strTorHost, iTorPort);
        //        Debug.WriteLine("Connected to Tor.");
        //        Byte[] arr_bHostName = new ASCIIEncoding().GetBytes(strDestHost);

        //        if (arr_bHostName == null) return null;

        //        Byte[] arr_bPort = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(iDestPort));

        //        if (arr_bPort == null) return null;

        //        Byte[] arr_bRecvBuffer = new Byte[MasterClient.ReceiveBufferSize];

        //        MasterClient.Send(new Byte[] { 5, 1, 0 });

        //        Debug.WriteLine("Sent first packet");

        //        Int32 iRead = MasterClient.Receive(arr_bRecvBuffer);

        //        Debug.WriteLine("Received first response.");

        //        if (iRead != 2 || arr_bRecvBuffer[0] != 5 || arr_bRecvBuffer[1] != 0)
        //            return null;
        //        Debug.WriteLine("Response ok.");
        //        Byte[] arr_bBuffer = new Byte[] { 5, 1, 0, 3, (byte)arr_bHostName.Length };

        //        /*using(MemoryStream msStream = new MemoryStream())
        //        {
        //            msStream.Write(arr_bBuffer, 0, arr_bBuffer.Length);
        //            msStream.Write(arr_bHostName, 0, arr_bHostName.Length);
        //            msStream.Write(new Byte[] { arr_bPort[0], arr_bPort[1] }, 0, 2);
        //            MasterClient.Send(msStream.ToArray());
        //        }*/

        //        MemoryStream msStream = new MemoryStream();
        //        msStream.Write(arr_bBuffer, 0, arr_bBuffer.Length);
        //        msStream.Write(arr_bHostName, 0, arr_bHostName.Length);
        //        msStream.Write(new Byte[] { arr_bPort[0], arr_bPort[1] }, 0, 2);

        //        MasterClient.Send(msStream.ToArray());
        //        Debug.WriteLine("Sent 2nd buffer.");

        //        iRead = MasterClient.Receive(arr_bRecvBuffer);

        //        Debug.WriteLine("Received 2nd response");

        //        if (arr_bRecvBuffer[0] != 5 || arr_bRecvBuffer[1] != 0)
        //            return null;

        //        Debug.WriteLine("2nd response ok.");

        //        return MasterClient;

        //    }
        //    catch
        //    {
            	
        //    }
        //    return null;
        //}
    }
}
