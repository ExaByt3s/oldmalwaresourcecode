#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")

#include "SocketClass.h"

pSocket::pSocket() {
	_socket = INVALID_SOCKET;

	WSADATA wsaData;
	if(WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
		// ERROR, run!
	}
}

pSocket::~pSocket() {
	if(_socket != INVALID_SOCKET) {
		closesocket(_socket);
	}

	if(WSACleanup() != 0) {
		// ERROR, run!
	}
}

BOOL pSocket::connect(char *host, unsigned short port) {
	struct addrinfo *result = NULL;
	struct addrinfo hints;
	
	ZeroMemory( &hints, sizeof(hints) );

	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	
	char port_str[64];
	_itoa_s(port, port_str, 10); // ISO C++
	//itoa(port, port_str, 10); //ISO C
	
	if(getaddrinfo(host, port_str, &hints, &result) != 0) {
		// Couldn't resolve host.
		return false;
	}

	_socket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
	if(_socket == INVALID_SOCKET) {
		// Couldn't create socket.
		free(result);
		return false;
	}
	if(::connect(_socket, result->ai_addr, (int)result->ai_addrlen) == SOCKET_ERROR) {
		/// Couldn't connect to remote host.
		closesocket(_socket);
		_socket = INVALID_SOCKET;
		return false;
	}
	ZeroMemory( &hints, sizeof(hints) );
	return true;
}

int pSocket::send(char *data, int len) {
		::send(_socket, data, len, 0);
		return 0;
}

int pSocket::recv(char * data, int len) {
		::recv(_socket, data, len, 0);
		return 0;
}